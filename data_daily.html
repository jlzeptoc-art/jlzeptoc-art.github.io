<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Production Schedule</title>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#111a33;
      --text:#e8ecff;
      --muted:#a9b3d6;
      --accent:#7aa7ff;
      --border:rgba(255,255,255,.10);
      --good:#3ddc97;
      --warn:#ffcf5a;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:ui-sans-serif, system-ui, -apple-system, sans-serif;
      background:linear-gradient(180deg, var(--bg), #070a16 70%);
      color:var(--text);
    }
    header{
      padding:24px 32px;
      border-bottom:1px solid var(--border);
      background:rgba(17,26,51,.85);
      backdrop-filter: blur(12px);
      position:sticky; top:0; z-index:10;
    }
    .header-content{
      display:flex;
      justify-content:space-between;
      align-items:center;
      flex-wrap:wrap;
      gap:16px;
    }
    header h1{
      margin:0; font-size:24px; font-weight:600; letter-spacing:-0.5px;
    }
    .schedule-info{
      display:flex;
      align-items:center;
      gap:16px;
      flex-wrap:wrap;
    }
    .schedule-date{
      font-size:16px;
      color:var(--text);
      font-weight:500;
    }
    .shift-badge{
      display:inline-flex;
      align-items:center;
      padding:6px 14px;
      border-radius:20px;
      font-size:13px;
      font-weight:500;
      background:rgba(122,167,255,.2);
      border:1px solid rgba(122,167,255,.3);
      color:var(--accent);
    }
    main{padding:24px 32px}
    .panel{
      background:rgba(17,26,51,.70);
      border:1px solid var(--border);
      border-radius:16px;
      padding:20px;
      box-shadow: 0 8px 32px rgba(0,0,0,.2);
      margin-bottom:20px;
    }
    .controls{
      display:flex;
      justify-content:space-between;
      align-items:center;
      flex-wrap:wrap;
      gap:16px;
    }
    select, button{
      border:1px solid var(--border);
      background:rgba(15,23,48,.85);
      color:var(--text);
      border-radius:12px;
      padding:12px 16px;
      outline:none;
      font-size:14px;
      transition:all 0.2s ease;
    }
    select{
      min-width:220px;
      cursor:pointer;
    }
    select:hover{
      border-color:rgba(122,167,255,.4);
    }
    button{
      cursor:pointer;
      font-weight:500;
      user-select:none;
      border-color:rgba(255,207,90,.4);
      background:rgba(255,207,90,.1);
    }
    button:hover{
      border-color:rgba(255,207,90,.6);
      background:rgba(255,207,90,.15);
      transform:translateY(-1px);
    }
    button:active{transform: translateY(0)}
    button:disabled{
      opacity:0.5;
      cursor:not-allowed;
    }
    .tableWrap{overflow:auto; border-radius:12px; border:1px solid var(--border); margin-top:10px}
    table{border-collapse:collapse; width:100%; min-width:700px; background:rgba(15,23,48,.65)}
    th, td{
      border-bottom:1px solid rgba(255,255,255,.08);
      padding:9px 10px;
      text-align:left;
      font-size:12.5px;
      white-space:nowrap;
    }
    th{
      position:sticky; top:0;
      background:rgba(17,26,51,.95);
      z-index:2;
      font-size:12px;
      color:var(--muted);
      letter-spacing:.2px;
    }
    tr:hover td{background:rgba(122,167,255,.07)}
    .line-header{
      background:rgba(122,167,255,.25) !important;
      font-weight:600;
      color:var(--text) !important;
      font-size:13px;
      padding:12px 10px;
    }
    .line-header td{
      border-bottom:2px solid rgba(122,167,255,.4);
    }
    .small{font-size:11px;color:var(--muted)}
    .printTitle{display:none}
    @media print{
      header, .controls{display:none !important}
      body{background:#fff;color:#000}
      main{padding:0}
      .panel{border:none; box-shadow:none; background:#fff}
      table{background:#fff; min-width:0}
      th{background:#f4f4f4;color:#000; border-bottom:1px solid #bbb}
      td{border-bottom:1px solid #ddd}
      .tableWrap{border:none}
      .printTitle{display:block !important; margin:8px 0 10px 0; font-size:16px;}
      .line-header{background:#e8e8e8 !important; color:#000 !important}
      .line-header td{border-bottom:2px solid #999}
    }
  </style>
</head>
<body>
<header>
  <div class="header-content">
    <h1>Production Schedule</h1>
    <div class="schedule-info">
      <span class="schedule-date" id="scheduleDate">—</span>
      <span class="shift-badge" id="shiftBadge">—</span>
    </div>
  </div>
</header>

<main>
  <div class="panel controls">
    <select id="daySelect" disabled></select>
    <button id="btnPrint" disabled>Print</button>
  </div>

  <div class="panel">
    <h2 class="printTitle" id="printTitle" style="margin:0 0 10px 0; font-size:16px;">
      Clean Production Schedule
    </h2>
    <div class="tableWrap">
      <table id="cleanTable">
        <thead>
          <tr>
            <th>Description</th>
            <th>SKU#</th>
            <th>Ordered</th>
            <th>Haz_Info</th>
            <th>Bottle Label Location</th>
            <th>Box Label Location</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
</main>

<script>
// Configuration: Set the XLSX file path here
const XLSX_FILE_PATH = 'Production Schedule Q1-Q2 2026.xlsx';

// State
let workbook = null;
let sheetNames = [];
let cleanRows = [];

// DOM
const $ = (id) => document.getElementById(id);
const daySelect = $("daySelect");
const btnPrint = $("btnPrint");
const scheduleDate = $("scheduleDate");
const shiftBadge = $("shiftBadge");
const cleanTable = $("cleanTable");

// Helpers
function normalizeHeader(s) {
  return String(s ?? "").trim().toLowerCase().replace(/\s+/g," ");
}

function looksLikeSku(value) {
  const v = String(value ?? "").trim();
  return v.length >= 3 && /^[A-Za-z0-9\-_\.]+$/.test(v);
}

function parseNumber(value) {
  if (value == null || value === "") return null;
  if (typeof value === "number" && isFinite(value)) return value;
  const v = String(value).replace(/,/g,"").trim();
  const n = Number(v);
  return isFinite(n) ? n : null;
}

function isPriority(value) {
  return /^[A-E]$/.test(String(value ?? "").trim().toUpperCase());
}

function safeStr(v) {
  return v == null ? "" : String(v).trim();
}

function pickSheetByNameLike(names, needle) {
  const n = needle.toLowerCase();
  return names.find(s => s.toLowerCase().includes(n));
}

// Get today's date in MM-DD format for sheet matching
function getTodaySheetFormat() {
  const today = new Date();
  const month = String(today.getMonth() + 1).padStart(2, '0');
  const day = String(today.getDate()).padStart(2, '0');
  return `${month}-${day}`;
}

// Detect shift from sheet name or data
function detectShift(sheetName, dayAoa) {
  const nameLower = sheetName.toLowerCase();
  
  // Check for PM (Second Shift) first
  if (nameLower.includes('pm')) {
    return 'Second Shift';
  }
  
  // Check sheet name for shift indicators
  if (nameLower.includes('first') || nameLower.includes('1st') || nameLower.includes('1')) {
    return 'First Shift';
  }
  if (nameLower.includes('second') || nameLower.includes('2nd') || nameLower.includes('2')) {
    return 'Second Shift';
  }
  
  // Check first few rows of data for shift indicators
  for (let r = 0; r < Math.min(20, dayAoa.length); r++) {
    const row = dayAoa[r] || [];
    const rowText = row.join(' ').toLowerCase();
    if (rowText.includes('first shift') || rowText.includes('1st shift')) {
      return 'First Shift';
    }
    if (rowText.includes('second shift') || rowText.includes('2nd shift') || rowText.includes('pm')) {
      return 'Second Shift';
    }
  }
  
  // Default to First Shift if not detected
  return 'First Shift';
}

// Format date from sheet name (e.g., "01-05" -> "Friday, January 5")
function formatScheduleDate(sheetName) {
  const match = sheetName.match(/(\d{1,2})-(\d{1,2})/);
  if (match) {
    const month = parseInt(match[1]);
    const day = parseInt(match[2]);
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                       'July', 'August', 'September', 'October', 'November', 'December'];
    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    
    if (month >= 1 && month <= 12) {
      // Try to determine year - check if workbook name has year, otherwise use current year
      let year = new Date().getFullYear();
      const workbookYearMatch = XLSX_FILE_PATH.match(/202[4-9]/);
      if (workbookYearMatch) {
        year = parseInt(workbookYearMatch[0]);
      }
      
      // Create date object to get day of week
      const date = new Date(year, month - 1, day);
      const dayOfWeek = dayNames[date.getDay()];
      
      return `${dayOfWeek}, ${monthNames[month - 1]} ${day}`;
    }
  }
  return sheetName;
}

// Find sheet matching today's date
function findTodaySheet(names) {
  const todayFormat = getTodaySheetFormat();
  // Try exact match first (e.g., "01-02")
  let match = names.find(s => s.trim() === todayFormat);
  if (match) return match;
  // Try without leading zeros (e.g., "1-2")
  const altFormat = todayFormat.replace(/^0+/, '').replace(/-0+/, '-');
  match = names.find(s => s.trim() === altFormat);
  if (match) return match;
  // Try contains today's format
  match = names.find(s => s.includes(todayFormat) || s.includes(altFormat));
  if (match) return match;
  // Fallback: find any sheet with date-like pattern
  return names.find(s => /^\d{1,2}-\d{1,2}$/.test(s.trim())) || null;
}

// Render clean table grouped by Line
function renderCleanRows(rows) {
  const tbody = cleanTable.querySelector("tbody");
  tbody.innerHTML = "";
  if (rows.length === 0) {
    tbody.innerHTML = '<tr><td colspan="6" style="text-align:center;padding:40px;color:var(--muted)">No schedule data found.</td></tr>';
    return;
  }
  
  // Group rows by Line
  const groupedByLine = new Map();
  for (const row of rows) {
    const line = row.Line || "Unknown";
    if (!groupedByLine.has(line)) {
      groupedByLine.set(line, []);
    }
    groupedByLine.get(line).push(row);
  }
  
  // Sort lines (Line #1, Line #2, etc.)
  const sortedLines = Array.from(groupedByLine.keys()).sort((a, b) => {
    const numA = parseInt(a.match(/\d+/)?.[0] || "999");
    const numB = parseInt(b.match(/\d+/)?.[0] || "999");
    return numA - numB;
  });
  
  // Render each line group
  for (const line of sortedLines) {
    const lineRows = groupedByLine.get(line);
    
    // Add Line header row
    const headerTr = document.createElement("tr");
    headerTr.className = "line-header";
    const headerTd = document.createElement("td");
    headerTd.colSpan = 6;
    headerTd.textContent = line;
    headerTr.appendChild(headerTd);
    tbody.appendChild(headerTr);
    
    // Add data rows for this line
    for (const row of lineRows) {
      const tr = document.createElement("tr");
      const cells = [
        row.Description, row["SKU#"], row.Ordered,
        row.Haz_Info, row["Bottle Label Location"], row["Box Label Location"]
      ];
      for (const v of cells) {
        const td = document.createElement("td");
        td.textContent = v == null ? "" : String(v);
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
  }
}

// Extract day sheet rows (A=Priority, B=Description, C=SKU, D=Ordered, I=Haz_Info, M=Bottle, N=Box)
// Also extracts Line information by detecting "Line #X" headers or Line column
function extractDayRows(dayAoa) {
  const rows = [];
  let currentLine = null;
  
  // Try to detect if Line is in a specific column (check column E/index 4, or scan for "line" header)
  let lineColIndex = -1;
  for (let r = 0; r < Math.min(10, dayAoa.length); r++) {
    const row = dayAoa[r] || [];
    for (let c = 0; c < row.length; c++) {
      const val = normalizeHeader(safeStr(row[c]));
      if (val.includes("line") && !val.includes("label")) {
        lineColIndex = c;
        break;
      }
    }
    if (lineColIndex >= 0) break;
  }
  // Fallback: try column E (index 4)
  if (lineColIndex < 0) lineColIndex = 4;
  
  for (let r = 0; r < dayAoa.length; r++) {
    const row = dayAoa[r] || [];
    
    // Check ALL cells in this row for a Line header (like "Line #1", "Line 1", etc.)
    let foundLineHeader = false;
    for (let c = 0; c < row.length; c++) {
      const cellValue = safeStr(row[c]);
      // Look for patterns like "Line #1", "Line 1", "Line1", "LINE 1", etc.
      const lineMatch = cellValue.match(/line\s*#?\s*(\d+)/i);
      if (lineMatch) {
        currentLine = `Line #${lineMatch[1]}`;
        foundLineHeader = true;
        break;
      }
    }
    
    // Also check the detected Line column for a line number
    if (!foundLineHeader && lineColIndex >= 0) {
      const lineCellValue = safeStr(row[lineColIndex] || "");
      // Check if it's just a number (like "1", "2") or "Line #1" format
      if (lineCellValue) {
        const numMatch = lineCellValue.match(/(\d+)/);
        if (numMatch && lineCellValue.trim().length < 10) {
          // Likely a line number
          currentLine = `Line #${numMatch[1]}`;
        } else {
          const lineMatch = lineCellValue.match(/line\s*#?\s*(\d+)/i);
          if (lineMatch) {
            currentLine = `Line #${lineMatch[1]}`;
          }
        }
      }
    }
    
    // If we found a Line header row (row with only Line info, no Priority/SKU), skip it
    if (foundLineHeader) {
      const priority = safeStr(row[0]).toUpperCase();
      const sku = safeStr(row[2]);
      // Only skip if it's NOT a valid schedule row
      if (!isPriority(priority) || !looksLikeSku(sku)) {
        continue;
      }
    }
    
    // Now check if this is a valid schedule row
    const priority = safeStr(row[0]).toUpperCase();
    const sku = safeStr(row[2]);
    
    // Skip if not a valid schedule row
    if (!isPriority(priority) || !looksLikeSku(sku)) continue;
    
    // Skip if we haven't found a Line yet (rows before first Line header)
    if (!currentLine) continue;

    rows.push({
      Line: currentLine,
      Description: safeStr(row[1]),
      "SKU#": sku,
      Ordered: parseNumber(row[3]) ?? safeStr(row[3]),
      Haz_Info: safeStr(row[8]),
      "Bottle Label Location": safeStr(row[12]),
      "Box Label Location": safeStr(row[13])
    });
  }
  
  return rows;
}

// Use day sheet data directly (no source lookup)
function buildCleanRows(dayRows) {
  return dayRows.map(dr => {
    // Handle empty Bottle Label Location - show "IN-HOUSE"
    const bottleLocation = safeStr(dr["Bottle Label Location"]);
    const finalBottle = bottleLocation ? bottleLocation : "IN-HOUSE";
    
    // Handle empty Box Label Location - show "IN-HOUSE"
    const boxLocation = safeStr(dr["Box Label Location"]);
    const finalBox = boxLocation ? boxLocation : "IN-HOUSE";
    
    // Handle Haz_Info - if 0, show nothing
    let hazInfo = dr.Haz_Info;
    if (hazInfo === 0 || hazInfo === "0" || safeStr(hazInfo) === "0") {
      hazInfo = "";
    }
    
    return {
      Line: dr.Line,
      Description: dr.Description,
      "SKU#": dr["SKU#"],
      Ordered: dr.Ordered,
      Haz_Info: hazInfo,
      "Bottle Label Location": finalBottle,
      "Box Label Location": finalBox
    };
  });
}

function sheetToAoa(name) {
  const ws = workbook.Sheets[name];
  return XLSX.utils.sheet_to_json(ws, { header: 1, raw: true, defval: "" });
}

// Populate day sheet select and auto-select
function populateSheetSelects() {
  daySelect.innerHTML = "";

  for (const n of sheetNames) {
    const opt = document.createElement("option");
    opt.value = n; opt.textContent = n;
    daySelect.appendChild(opt);
  }

  // Auto-detect today's sheet
  const todaySheet = findTodaySheet(sheetNames);
  daySelect.value = todaySheet || sheetNames[1] || sheetNames[0];
}

// Build clean table
function build() {
  if (!workbook) return;

  const dayName = daySelect.value;
  const dayAoa = sheetToAoa(dayName);

  const dayRows = extractDayRows(dayAoa);
  cleanRows = buildCleanRows(dayRows);

  // Update header with schedule info
  const shift = detectShift(dayName, dayAoa);
  const formattedDate = formatScheduleDate(dayName);
  
  scheduleDate.textContent = formattedDate;
  shiftBadge.textContent = shift;

  $("printTitle").textContent = `Clean Production Schedule — ${dayName}`;
  renderCleanRows(cleanRows);
  btnPrint.disabled = cleanRows.length === 0;
}

// Load XLSX file automatically
async function loadWorkbook() {
  try {
    const response = await fetch(XLSX_FILE_PATH);
    if (!response.ok) throw new Error(`Failed to load file: ${response.statusText}`);
    
    const buf = await response.arrayBuffer();
    workbook = XLSX.read(buf, { type: "array" });
    sheetNames = workbook.SheetNames || [];

    populateSheetSelects();
    daySelect.disabled = false;
    
    // Auto-build on load
    build();
  } catch (err) {
    console.error(err);
    scheduleDate.textContent = "Error loading file";
    shiftBadge.textContent = "—";
    alert(`Error loading file: ${err.message}. Make sure "${XLSX_FILE_PATH}" exists in the same directory.`);
  }
}

// Event listeners
daySelect.addEventListener("change", () => {
  if (!workbook) return;
  build(); // Auto-build when day sheet changes
});

btnPrint.addEventListener("click", () => { if (cleanRows.length) window.print(); });

// Initialize
loadWorkbook();
</script>
</body>
</html>
