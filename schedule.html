<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Production Schedule</title>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root{
      --bg:#f5f7fa;
      --panel:#ffffff;
      --text:#2d3748;
      --muted:#718096;
      --accent:#3182ce;
      --accent-dark:#2c5282;
      --border:#e2e8f0;
      --line-accent:#4299e1;
      --line-bg:#ebf8ff;
      --hover:#f7fafc;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:"Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background:var(--bg);
      color:var(--text);
      line-height:1.6;
    }
    header{
      padding:28px 40px;
      background:linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
      color:white;
      box-shadow:0 4px 6px rgba(0,0,0,.1);
      position:sticky; top:0; z-index:10;
    }
    .header-content{
      display:flex;
      justify-content:space-between;
      align-items:center;
      flex-wrap:wrap;
      gap:20px;
      max-width:1600px;
      margin:0 auto;
    }
    header h1{
      margin:0; 
      font-size:28px; 
      font-weight:700; 
      letter-spacing:-0.8px;
      text-shadow:0 2px 4px rgba(0,0,0,.1);
    }
    .schedule-info{
      display:flex;
      align-items:center;
      gap:16px;
      flex-wrap:wrap;
    }
    .schedule-date{
      font-size:16px;
      color:rgba(255,255,255,.95);
      font-weight:600;
      background:rgba(255,255,255,.15);
      padding:8px 16px;
      border-radius:8px;
      backdrop-filter:blur(10px);
    }
    .shift-badge{
      display:inline-flex;
      align-items:center;
      padding:8px 16px;
      border-radius:8px;
      font-size:13px;
      font-weight:600;
      background:rgba(255,255,255,.2);
      border:1px solid rgba(255,255,255,.3);
      color:white;
      backdrop-filter:blur(10px);
    }
    main{
      padding:32px 40px;
      max-width:1600px;
      margin:0 auto;
    }
    .panel{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:12px;
      padding:24px;
      box-shadow:0 2px 8px rgba(0,0,0,.06);
      margin-bottom:24px;
    }
    .controls{
      display:flex;
      justify-content:flex-start;
      align-items:center;
      flex-wrap:wrap;
      gap:12px;
      padding:20px;
      background:linear-gradient(to right, #f8fafc, #f1f5f9);
      border-radius:10px;
      border:1px solid var(--border);
    }
    select, button{
      border:1px solid var(--border);
      background:white;
      color:var(--text);
      border-radius:8px;
      padding:11px 18px;
      outline:none;
      font-size:14px;
      transition:all 0.2s ease;
      font-weight:500;
      box-shadow:0 1px 2px rgba(0,0,0,.05);
    }
    input{
      border:1px solid var(--border);
      background:white;
      color:var(--text);
      border-radius:8px;
      padding:11px 18px;
      outline:none;
      font-size:14px;
      transition:all 0.2s ease;
      font-weight:500;
      box-shadow:0 1px 2px rgba(0,0,0,.05);
      min-width:320px;
    }
    select{
      min-width:240px;
      cursor:pointer;
      appearance:none;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%233182ce' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
      background-repeat:no-repeat;
      background-position:right 14px center;
      padding-right:40px;
    }
    select:hover, select:focus{
      border-color:var(--accent);
      box-shadow:0 0 0 3px rgba(49,130,206,.1);
    }
    input:hover, input:focus{
      border-color:var(--accent);
      box-shadow:0 0 0 3px rgba(49,130,206,.1);
    }
    button{
      cursor:pointer;
      user-select:none;
      background:var(--accent);
      color:white;
      border-color:var(--accent);
      font-weight:600;
      padding:11px 24px;
    }
    button:hover{
      background:var(--accent-dark);
      border-color:var(--accent-dark);
      transform:translateY(-1px);
      box-shadow:0 4px 6px rgba(0,0,0,.1);
    }
    button:active{transform: translateY(0)}
    button:disabled{
      opacity:0.5;
      cursor:not-allowed;
      background:#cbd5e0;
      border-color:#cbd5e0;
    }
    .tableWrap{
      overflow:auto;
      border-radius:8px;
      border:1px solid var(--border);
      margin-top:16px;
      box-shadow:inset 0 2px 4px rgba(0,0,0,.04);
    }
    table{
      border-collapse:collapse;
      width:100%;
      min-width:700px;
      background:white;
    }
    th, td{
      border-bottom:1px solid var(--border);
      padding:14px 16px;
      text-align:left;
      font-size:13px;
    }
    th{
      position:sticky;
      top:0;
      background:#f8fafc;
      z-index:2;
      font-size:12px;
      color:var(--muted);
      font-weight:700;
      text-transform:uppercase;
      letter-spacing:0.8px;
      border-bottom:2px solid var(--accent);
      color:var(--accent);
    }
    tr:hover td{
      background:var(--hover);
    }
    .line-header{
      background:var(--line-bg) !important;
      font-weight:700;
      color:var(--accent-dark) !important;
      font-size:14px;
      padding:16px;
    }
    .line-header td{
      border-bottom:3px solid var(--line-accent);
      font-size:15px;
    }
    .pick-wrap{
      display:flex;
      align-items:center;
      gap:10px;
    }
    .pick-checkbox{
      width:18px;
      height:18px;
      flex:0 0 auto;
      accent-color: var(--accent);
    }
    .small{font-size:11px;color:var(--muted)}
    .footer-info{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-top:2rem;
      padding-top:1.5rem;
      border-top:1px solid var(--border);
    }
    .footer-info img{
      height:50px;
      opacity:0.9;
    }
    .footer-nav{
      display:flex;
      align-items:center;
      gap:16px;
    }
    .footer-nav a{
      color:var(--accent);
      text-decoration:none;
      font-weight:500;
      font-size:13px;
      transition:color 0.2s ease;
    }
    .footer-nav a:hover{
      color:var(--accent-dark);
      text-decoration:underline;
    }
    .printTitle{display:none}
    .printHeader{display:none}
    @page{
      size: letter landscape;
      margin:0.5in;
    }
    @media print{
      *{margin:0; padding:0; box-sizing:border-box}
      html, body{
        width:100%;
        height:100%;
        margin:0;
        padding:0;
        background:var(--bg);
        color:var(--text);
        overflow:visible;
      }
      header, .controls, .status, .footer-info{display:none !important}
      .source-panel{display:none !important}
      main{
        padding:0;
        margin:0;
        width:100%;
        height:100%;
      }
      .schedule-panel{
        border:none;
        box-shadow:none;
        background:transparent;
        padding:0;
        margin:0;
        width:100%;
        height:100%;
        display:flex;
        flex-direction:column;
      }
      .printHeader{
        display:flex !important;
        justify-content:space-between;
        align-items:center;
        margin-bottom:12px;
        padding-bottom:8px;
        border-bottom:1px solid var(--border);
        width:100%;
      }
      .printTitle{
        display:block !important;
        margin:0 0 4px 0;
        font-size:18px;
        font-weight:600;
        color:var(--text);
      }
      .printHeader .printDate{
        font-size:14px;
        color:var(--text);
        font-weight:500;
      }
      .printHeader .printShift{
        display:inline-flex;
        align-items:center;
        padding:4px 12px;
        border-radius:16px;
        font-size:12px;
        font-weight:500;
        background:rgba(122,167,255,.2);
        border:1px solid rgba(122,167,255,.3);
        color:var(--accent);
      }
      .tableWrap{
        border:none;
        overflow:visible;
        flex:1;
        width:100%;
      }
      table{
        background:white;
        width:100%;
        min-width:0;
        font-size:11px;
      }
      th{
        background:#f8fafc;
        color:#4a5568;
        border-bottom:1px solid #cbd5e0;
        padding:6px 8px;
        font-size:11px;
        position:static;
      }
      td{
        border-bottom:1px solid #e2e8f0;
        color:#111827;
        padding:6px 8px;
        font-size:11px;
      }
      .pick-checkbox{display:none !important}
      .line-header{
        background:#ebf8ff !important;
        color:#1e3a8a !important;
      }
      .line-header td{
        border-bottom:2px solid rgba(66,153,225,.6);
        padding:8px;
        font-weight:600;
      }
    }
  </style>
</head>
<body>
<header>
  <div class="header-content">
    <h1>Production Schedule</h1>
    <div class="schedule-info">
      <span class="schedule-date" id="scheduleDate">—</span>
      <span class="shift-badge" id="shiftBadge">—</span>
    </div>
  </div>
</header>

<main>
  <div class="panel controls">
    <select id="daySelect" disabled></select>
    <button id="btnPrint" disabled>Print</button>
  </div>

  <div class="panel schedule-panel">
    <div class="printHeader">
      <div>
        <h2 class="printTitle" id="printTitle" style="margin:0 0 4px 0; font-size:16px;">
          Production Schedule
        </h2>
        <span class="printDate" id="printDate">—</span>
      </div>
      <span class="printShift" id="printShift">—</span>
    </div>
    <div class="tableWrap">
      <table id="cleanTable">
        <thead>
          <tr>
            <th>Description</th>
            <th>SKU#</th>
            <th>Ordered (UOM)</th>
            <th>Haz_Info</th>
            <th>Bottle Label Location</th>
            <th>Box Label Location</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div class="panel source-panel">
    <div style="display:flex; justify-content:space-between; align-items:flex-end; gap:16px; flex-wrap:wrap;">
      <div>
        <div style="font-weight:700; font-size:16px; margin-bottom:4px;">Search Source</div>
        <div class="small">Search by Item Number or Description (from the <strong>Source</strong> tab).</div>
      </div>
      <div class="small" id="sourceSearchStatus" style="text-align:right;">Loading…</div>
    </div>

    <div class="controls" style="margin-top:16px;">
      <input id="sourceSearch" type="text" placeholder="Type item number or description…" disabled />
      <button id="sourceSearchBtn" disabled>Search</button>
      <button id="sourceClearBtn" disabled style="background:white;color:var(--accent);border-color:var(--border);">Clear</button>
    </div>

    <div class="tableWrap">
      <table id="sourceResultsTable">
        <thead>
          <tr>
            <th>Item #</th>
            <th>Description</th>
            <th>Haz Info</th>
            <th>Insert Info</th>
            <th>Label Location</th>
            <th>Box Label Location</th>
            <th>Closure Type</th>
            <th>Pack Type</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div class="footer-info">
    <div>
      <div class="muted" style="font-size:13px;">App made by <strong>J.L.</strong></div>
      <div class="footer-nav" style="margin-top:8px;">
        <a href="index.html">Product Weight Calculator</a>
      </div>
    </div>
    <img src="maintex-logo.jpg" alt="Maintex Logo">
  </div>
</main>

<script>
// Configuration: Set the XLSX file path here
const XLSX_FILE_PATH = 'Production Schedule Q1-Q2 2026.xlsx';

// Optional shared storage for "picked" checkboxes (Google Apps Script Web App URL).
// If blank, the picked state is saved only on the current device/browser.
const PICK_STATUS_ENDPOINT = '';

// State
let workbook = null;
let allSheetNames = [];
let sheetNames = []; // schedule day sheets only (for dropdown)
let cleanRows = [];
let sourceRecords = [];
let sourceReady = false;

// Pick status cache (per day sheet)
let pickState = new Map(); // key -> boolean

// DOM
const $ = (id) => document.getElementById(id);
const daySelect = $("daySelect");
const btnPrint = $("btnPrint");
const scheduleDate = $("scheduleDate");
const shiftBadge = $("shiftBadge");
const cleanTable = $("cleanTable");
const sourceSearch = $("sourceSearch");
const sourceSearchBtn = $("sourceSearchBtn");
const sourceClearBtn = $("sourceClearBtn");
const sourceResultsTable = $("sourceResultsTable");
const sourceSearchStatus = $("sourceSearchStatus");

// Helpers
function normalizeHeader(s) {
  return String(s ?? "").trim().toLowerCase().replace(/\s+/g," ");
}

function looksLikeSku(value) {
  const v = String(value ?? "").trim();
  return v.length >= 3 && /^[A-Za-z0-9\-_\.]+$/.test(v);
}

function parseNumber(value) {
  if (value == null || value === "") return null;
  if (typeof value === "number" && isFinite(value)) return value;
  const v = String(value).replace(/,/g,"").trim();
  const n = Number(v);
  return isFinite(n) ? n : null;
}

function isPriority(value) {
  return /^[A-E]$/.test(String(value ?? "").trim().toUpperCase());
}

function safeStr(v) {
  return v == null ? "" : String(v).trim();
}

function pickSheetByNameLike(names, needle) {
  const n = needle.toLowerCase();
  return names.find(s => s.toLowerCase().includes(n));
}

function norm(s) {
  return String(s ?? "").trim().toLowerCase();
}

function pickHeader(keys, regexList) {
  const lowered = keys.map(k => ({ orig: k, low: norm(k) }));
  for (const rx of regexList) {
    const re = new RegExp(rx);
    const hit = lowered.find(({ low }) => re.test(low));
    if (hit) return hit.orig;
  }
  return null;
}

function hashKey(str) {
  // FNV-1a 32-bit
  let h = 0x811c9dc5;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 0x01000193);
  }
  // unsigned to base36 for shorter keys
  return (h >>> 0).toString(36);
}

function makePickKey(dayName, row, kind) {
  const raw = `${dayName}|${row.Line}|${row["SKU#"]}|${row.Description}|${kind}`;
  return `pick:${hashKey(raw)}`;
}

function lineNumberFromLabel(lineLabel) {
  const m = String(lineLabel ?? "").match(/(\d+)/);
  return m ? parseInt(m[1], 10) : null;
}

function uomForScheduleRow(row) {
  const lineNum = lineNumberFromLabel(row.Line);
  if ([1, 2, 3, 4, 6, 7].includes(lineNum)) return "CS";
  if (lineNum === 5) {
    const d = String(row.Description ?? "").toLowerCase();
    // Best-effort separation for Line 5
    if (d.includes("drum") || /\bdr\b/.test(d)) return "DR";
    if (d.includes("pail") || /\bpl\b/.test(d)) return "PL";
    return "EA";
  }
  return "";
}

function localPickStorageKey(key) {
  return `maintex:schedule:picks:v1:${key}`;
}

async function pickBulkGet(keys) {
  // Returns Map(key -> boolean)
  const out = new Map();
  if (!keys.length) return out;

  // Remote (shared) mode
  if (PICK_STATUS_ENDPOINT) {
    try {
      const resp = await fetch(PICK_STATUS_ENDPOINT, {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ action: "bulkGet", keys })
      });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const data = await resp.json();
      const values = data?.values || {};
      for (const k of keys) out.set(k, Boolean(values[k]));
      return out;
    } catch (e) {
      console.warn("Pick bulkGet failed, falling back to local storage.", e);
      // fall through to local
    }
  }

  // Local fallback
  for (const k of keys) {
    const v = localStorage.getItem(localPickStorageKey(k));
    out.set(k, v === "1");
  }
  return out;
}

async function pickSet(key, value) {
  // Remote (shared) mode
  if (PICK_STATUS_ENDPOINT) {
    const resp = await fetch(PICK_STATUS_ENDPOINT, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({ action: "set", key, value: Boolean(value) })
    });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    return;
  }

  // Local fallback
  localStorage.setItem(localPickStorageKey(key), value ? "1" : "0");
}

// Get today's date in MM-DD format for sheet matching
function getTodaySheetFormat() {
  const today = new Date();
  const month = String(today.getMonth() + 1).padStart(2, '0');
  const day = String(today.getDate()).padStart(2, '0');
  return `${month}-${day}`;
}

// Detect shift from sheet name or data
function detectShift(sheetName, dayAoa) {
  const nameLower = sheetName.toLowerCase();
  
  // Workbook convention: "MM-DD" (first shift) vs "MM-DD PM"/"MM-DDpm" (second shift)
  if (/\bpm\b/i.test(sheetName) || /pm$/i.test(sheetName.trim())) {
    return 'Second Shift';
  }
  
  // Check first few rows of data for shift indicators
  for (let r = 0; r < Math.min(20, dayAoa.length); r++) {
    const row = dayAoa[r] || [];
    const rowText = row.join(' ').toLowerCase();
    if (rowText.includes('first shift') || rowText.includes('1st shift')) {
      return 'First Shift';
    }
    if (rowText.includes('second shift') || rowText.includes('2nd shift') || rowText.includes('pm')) {
      return 'Second Shift';
    }
  }
  
  // Default to First Shift if not detected
  return 'First Shift';
}

// Format date from sheet name (e.g., "01-05" -> "Friday, January 5")
function formatScheduleDate(sheetName) {
  const match = sheetName.match(/(\d{1,2})-(\d{1,2})/);
  if (match) {
    const month = parseInt(match[1]);
    const day = parseInt(match[2]);
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                       'July', 'August', 'September', 'October', 'November', 'December'];
    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    
    if (month >= 1 && month <= 12) {
      // Try to determine year - check if workbook name has year, otherwise use current year
      let year = new Date().getFullYear();
      const workbookYearMatch = XLSX_FILE_PATH.match(/202[4-9]/);
      if (workbookYearMatch) {
        year = parseInt(workbookYearMatch[0]);
      }
      
      // Create date object to get day of week
      const date = new Date(year, month - 1, day);
      const dayOfWeek = dayNames[date.getDay()];
      
      return `${dayOfWeek}, ${monthNames[month - 1]} ${day}, ${year}`;
    }
  }
  return sheetName;
}

// Check if a sheet exists for a given date
function sheetExistsForDate(names, month, day) {
  const formats = [
    `${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`, // "01-03"
    `${month}-${day}`, // "1-3"
    `${String(month).padStart(2, '0')}-${day}`, // "01-3"
    `${month}-${String(day).padStart(2, '0')}` // "1-03"
  ];
  
  return names.find(s => {
    const trimmed = s.trim();
    return formats.some(format => 
      trimmed === format || trimmed.startsWith(format)
    );
  });
}

// Find sheet matching today's date or next available workday
function findTodaySheet(names) {
  const today = new Date();
  let checkDate = new Date(today);
  const maxDaysAhead = 14; // Look up to 2 weeks ahead
  let daysChecked = 0;
  
  while (daysChecked < maxDaysAhead) {
    const month = checkDate.getMonth() + 1;
    const day = checkDate.getDate();
    const dayOfWeek = checkDate.getDay(); // 0 = Sunday, 6 = Saturday
    
    // Skip weekends - if Saturday, jump to Monday; if Sunday, jump to Monday
    if (dayOfWeek === 6) { // Saturday
      checkDate.setDate(checkDate.getDate() + 2); // Jump to Monday
      daysChecked += 2;
      continue;
    }
    if (dayOfWeek === 0) { // Sunday
      checkDate.setDate(checkDate.getDate() + 1); // Jump to Monday
      daysChecked += 1;
      continue;
    }
    
    // Check if sheet exists for this date
    const match = sheetExistsForDate(names, month, day);
    if (match) {
      return match;
    }
    
    // Move to next day
    checkDate.setDate(checkDate.getDate() + 1);
    daysChecked++;
  }
  
  // If no match found after checking ahead, return null
  return null;
}

// Render clean table grouped by Line
function renderCleanRows(rows, dayName) {
  const tbody = cleanTable.querySelector("tbody");
  tbody.innerHTML = "";
  if (rows.length === 0) {
    tbody.innerHTML = '<tr><td colspan="6" style="text-align:center;padding:40px;color:var(--muted)">No schedule data found.</td></tr>';
    return;
  }
  
  // Group rows by Line
  const groupedByLine = new Map();
  for (const row of rows) {
    const line = row.Line || "Unknown";
    if (!groupedByLine.has(line)) {
      groupedByLine.set(line, []);
    }
    groupedByLine.get(line).push(row);
  }
  
  // Sort lines (Line #1, Line #2, etc.)
  const sortedLines = Array.from(groupedByLine.keys()).sort((a, b) => {
    const numA = parseInt(a.match(/\d+/)?.[0] || "999");
    const numB = parseInt(b.match(/\d+/)?.[0] || "999");
    return numA - numB;
  });
  
  // Render each line group
  for (const line of sortedLines) {
    const lineRows = groupedByLine.get(line);
    
    // Add Line header row
    const headerTr = document.createElement("tr");
    headerTr.className = "line-header";
    const headerTd = document.createElement("td");
    headerTd.colSpan = 6;
    headerTd.textContent = line;
    headerTr.appendChild(headerTd);
    tbody.appendChild(headerTr);
    
    // Add data rows for this line
    for (const row of lineRows) {
      const tr = document.createElement("tr");
      // Description
      const tdDesc = document.createElement("td");
      tdDesc.textContent = row.Description ?? "";
      tr.appendChild(tdDesc);

      // SKU#
      const tdSku = document.createElement("td");
      tdSku.textContent = row["SKU#"] ?? "";
      tr.appendChild(tdSku);

      // Ordered
      const tdOrd = document.createElement("td");
      const uom = uomForScheduleRow(row);
      const ord = row.Ordered == null ? "" : String(row.Ordered);
      tdOrd.textContent = ord ? (uom ? `${ord} ${uom}` : ord) : "";
      tr.appendChild(tdOrd);

      // Haz_Info
      const tdHaz = document.createElement("td");
      tdHaz.textContent = row.Haz_Info ?? "";
      tr.appendChild(tdHaz);

      // Bottle Label Location + picked checkbox
      const bottleKey = makePickKey(dayName, row, "bottle");
      const tdBottle = document.createElement("td");
      const bottleWrap = document.createElement("div");
      bottleWrap.className = "pick-wrap";
      const bottleCb = document.createElement("input");
      bottleCb.type = "checkbox";
      bottleCb.className = "pick-checkbox";
      bottleCb.checked = Boolean(pickState.get(bottleKey));
      bottleCb.setAttribute("aria-label", "Bottle label picked");
      bottleCb.addEventListener("change", async () => {
        const next = bottleCb.checked;
        pickState.set(bottleKey, next);
        try {
          await pickSet(bottleKey, next);
        } catch (e) {
          console.error(e);
          pickState.set(bottleKey, !next);
          bottleCb.checked = !next;
          alert("Could not save picked status. Please try again.");
        }
      });
      const bottleText = document.createElement("span");
      bottleText.textContent = row["Bottle Label Location"] ?? "";
      bottleWrap.appendChild(bottleCb);
      bottleWrap.appendChild(bottleText);
      tdBottle.appendChild(bottleWrap);
      tr.appendChild(tdBottle);

      // Box Label Location + picked checkbox
      const boxKey = makePickKey(dayName, row, "box");
      const tdBox = document.createElement("td");
      const boxWrap = document.createElement("div");
      boxWrap.className = "pick-wrap";
      const boxCb = document.createElement("input");
      boxCb.type = "checkbox";
      boxCb.className = "pick-checkbox";
      boxCb.checked = Boolean(pickState.get(boxKey));
      boxCb.setAttribute("aria-label", "Box label picked");
      boxCb.addEventListener("change", async () => {
        const next = boxCb.checked;
        pickState.set(boxKey, next);
        try {
          await pickSet(boxKey, next);
        } catch (e) {
          console.error(e);
          pickState.set(boxKey, !next);
          boxCb.checked = !next;
          alert("Could not save picked status. Please try again.");
        }
      });
      const boxText = document.createElement("span");
      boxText.textContent = row["Box Label Location"] ?? "";
      boxWrap.appendChild(boxCb);
      boxWrap.appendChild(boxText);
      tdBox.appendChild(boxWrap);
      tr.appendChild(tdBox);

      tbody.appendChild(tr);
    }
  }
}

// Extract day sheet rows (A=Priority, B=Description, C=SKU, D=Ordered, I=Haz_Info, M=Bottle, N=Box)
// Also extracts Line information by detecting "Line #X" headers or Line column
function extractDayRows(dayAoa) {
  const rows = [];
  let currentLine = null;
  
  // Try to detect if Line is in a specific column (check column E/index 4, or scan for "line" header)
  let lineColIndex = -1;
  for (let r = 0; r < Math.min(10, dayAoa.length); r++) {
    const row = dayAoa[r] || [];
    for (let c = 0; c < row.length; c++) {
      const val = normalizeHeader(safeStr(row[c]));
      if (val.includes("line") && !val.includes("label")) {
        lineColIndex = c;
        break;
      }
    }
    if (lineColIndex >= 0) break;
  }
  // Fallback: try column E (index 4)
  if (lineColIndex < 0) lineColIndex = 4;
  
  for (let r = 0; r < dayAoa.length; r++) {
    const row = dayAoa[r] || [];
    
    // Check ALL cells in this row for a Line header (like "Line #1", "Line 1", etc.)
    let foundLineHeader = false;
    for (let c = 0; c < row.length; c++) {
      const cellValue = safeStr(row[c]);
      // Look for patterns like "Line #1", "Line 1", "Line1", "LINE 1", etc.
      const lineMatch = cellValue.match(/line\s*#?\s*(\d+)/i);
      if (lineMatch) {
        currentLine = `Line #${lineMatch[1]}`;
        foundLineHeader = true;
        break;
      }
    }
    
    // Also check the detected Line column for a line number
    if (!foundLineHeader && lineColIndex >= 0) {
      const lineCellValue = safeStr(row[lineColIndex] || "");
      // Check if it's just a number (like "1", "2") or "Line #1" format
      if (lineCellValue) {
        const numMatch = lineCellValue.match(/(\d+)/);
        if (numMatch && lineCellValue.trim().length < 10) {
          // Likely a line number
          currentLine = `Line #${numMatch[1]}`;
        } else {
          const lineMatch = lineCellValue.match(/line\s*#?\s*(\d+)/i);
          if (lineMatch) {
            currentLine = `Line #${lineMatch[1]}`;
          }
        }
      }
    }
    
    // If we found a Line header row (row with only Line info, no Priority/SKU), skip it
    if (foundLineHeader) {
      const priority = safeStr(row[0]).toUpperCase();
      const sku = safeStr(row[2]);
      // Only skip if it's NOT a valid schedule row
      if (!isPriority(priority) || !looksLikeSku(sku)) {
        continue;
      }
    }
    
    // Now check if this is a valid schedule row
    const priority = safeStr(row[0]).toUpperCase();
    const sku = safeStr(row[2]);
    
    // Skip if not a valid schedule row
    if (!isPriority(priority) || !looksLikeSku(sku)) continue;
    
    // Skip if we haven't found a Line yet (rows before first Line header)
    if (!currentLine) continue;

    rows.push({
      Line: currentLine,
      Description: safeStr(row[1]),
      "SKU#": sku,
      Ordered: parseNumber(row[3]) ?? safeStr(row[3]),
      Haz_Info: safeStr(row[8]),
      "Bottle Label Location": safeStr(row[12]),
      "Box Label Location": safeStr(row[13])
    });
  }
  
  return rows;
}

// Use day sheet data directly (no source lookup)
function buildCleanRows(dayRows) {
  return dayRows.map(dr => {
    // Handle empty Bottle Label Location - show "IN-HOUSE"
    const bottleLocation = safeStr(dr["Bottle Label Location"]);
    const finalBottle = bottleLocation ? bottleLocation : "IN-HOUSE";
    
    // Handle empty Box Label Location - show "IN-HOUSE"
    const boxLocation = safeStr(dr["Box Label Location"]);
    const finalBox = boxLocation ? boxLocation : "IN-HOUSE";
    
    // Handle Haz_Info - if 0, show nothing
    let hazInfo = dr.Haz_Info;
    if (hazInfo === 0 || hazInfo === "0" || safeStr(hazInfo) === "0") {
      hazInfo = "";
    }
    
    return {
      Line: dr.Line,
      Description: dr.Description,
      "SKU#": dr["SKU#"],
      Ordered: dr.Ordered,
      Haz_Info: hazInfo,
      "Bottle Label Location": finalBottle,
      "Box Label Location": finalBox
    };
  });
}

function sheetToAoa(name) {
  const ws = workbook.Sheets[name];
  return XLSX.utils.sheet_to_json(ws, { header: 1, raw: true, defval: "" });
}

// Populate day sheet select and auto-select
function populateSheetSelects() {
  daySelect.innerHTML = "";

  for (const n of sheetNames) {
    const opt = document.createElement("option");
    opt.value = n; opt.textContent = n;
    daySelect.appendChild(opt);
  }

  // Auto-detect today's sheet or next available workday
  const todaySheet = findTodaySheet(sheetNames);
  if (todaySheet) {
    daySelect.value = todaySheet;
    const today = new Date();
    const todayFormat = getTodaySheetFormat();
    const match = todaySheet.match(/(\d{1,2})-(\d{1,2})/);
    if (match) {
      const sheetDate = `${match[1]}-${match[2]}`;
      if (sheetDate !== todayFormat) {
        console.log(`Today's sheet (${todayFormat}) not found. Showing next available workday: ${todaySheet}`);
      }
    }
  } else {
    // If no workday found in next 2 weeks, select first sheet
    daySelect.value = sheetNames[0] || sheetNames[1] || "";
    console.log(`No workday sheets found. Showing first available sheet.`);
  }
}

// Build clean table
function build() {
  if (!workbook) return;

  const dayName = daySelect.value;
  const dayAoa = sheetToAoa(dayName);

  const dayRows = extractDayRows(dayAoa);
  cleanRows = buildCleanRows(dayRows);

  // Update header with schedule info
  const shift = detectShift(dayName, dayAoa);
  const formattedDate = formatScheduleDate(dayName);
  
  scheduleDate.textContent = formattedDate;
  shiftBadge.textContent = shift;
  
  // Update print header
  $("printDate").textContent = formattedDate;
  $("printShift").textContent = shift;

  renderCleanRows(cleanRows, dayName);
  btnPrint.disabled = cleanRows.length === 0;
}

// Load XLSX file automatically
async function loadWorkbook() {
  try {
    const response = await fetch(XLSX_FILE_PATH);
    if (!response.ok) throw new Error(`Failed to load file: ${response.statusText}`);
    
    const buf = await response.arrayBuffer();
    workbook = XLSX.read(buf, { type: "array" });
    // Only include schedule day sheets (e.g. "01-05" and "01-05 PM")
    allSheetNames = workbook.SheetNames || [];
    sheetNames = allSheetNames.filter((n) => /^\s*\d{1,2}-\d{1,2}/.test(String(n)));

    populateSheetSelects();
    daySelect.disabled = false;
    
    // Load Source sheet for search
    loadSourceSheet();

    // Auto-build on load
    build();
  } catch (err) {
    console.error(err);
    scheduleDate.textContent = "Error loading file";
    shiftBadge.textContent = "—";
    alert(`Error loading file: ${err.message}. Make sure "${XLSX_FILE_PATH}" exists in the same directory.`);
  }
}

function setSourceStatus(msg) {
  if (!sourceSearchStatus) return;
  sourceSearchStatus.textContent = msg || "";
}

function renderSourceResults(records) {
  const tbody = sourceResultsTable.querySelector("tbody");
  tbody.innerHTML = "";

  if (!records.length) {
    tbody.innerHTML = '<tr><td colspan="8" style="text-align:center;padding:28px;color:var(--muted)">No results.</td></tr>';
    return;
  }

  const maxRows = 200;
  const shown = records.slice(0, maxRows);

  for (const r of shown) {
    const tr = document.createElement("tr");
    const cells = [
      r.itemNumber,
      r.description,
      r.hazInfo,
      r.insertInfo,
      r.labelLocation,
      r.boxLabelLocation,
      r.closureType,
      r.packType
    ];
    for (const v of cells) {
      const td = document.createElement("td");
      td.textContent = v == null ? "" : String(v);
      tr.appendChild(td);
    }
    tbody.appendChild(tr);
  }

  if (records.length > maxRows) {
    const tr = document.createElement("tr");
    const td = document.createElement("td");
    td.colSpan = 8;
    td.style.textAlign = "center";
    td.style.padding = "14px";
    td.style.color = "var(--muted)";
    td.textContent = `Showing first ${maxRows} of ${records.length} matches. Refine your search to narrow results.`;
    tr.appendChild(td);
    tbody.appendChild(tr);
  }
}

function normalizeHaz(value) {
  const s = safeStr(value);
  if (s === "0") return "";
  return s;
}

function loadSourceSheet() {
  sourceReady = false;
  sourceRecords = [];
  renderSourceResults([]);

  if (!workbook) {
    setSourceStatus("Source: workbook not loaded.");
    return;
  }

  const sourceName =
    allSheetNames.find(n => norm(n) === "source") ||
    pickSheetByNameLike(allSheetNames, "source");

  if (!sourceName || !workbook.Sheets[sourceName]) {
    setSourceStatus('Source sheet not found (expected a tab named "Source").');
    sourceSearch.disabled = true;
    sourceSearchBtn.disabled = true;
    sourceClearBtn.disabled = true;
    return;
  }

  const ws = workbook.Sheets[sourceName];
  // Use AOA so we can detect header row even if it's not row 1 (Source has a title block).
  const aoa = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "", raw: true });
  if (!aoa.length) {
    setSourceStatus('Source sheet is empty.');
    sourceSearch.disabled = false;
    sourceSearchBtn.disabled = false;
    sourceClearBtn.disabled = false;
    return;
  }

  const normCell = (v) => String(v ?? "").trim().toLowerCase();
  const isMatch = (cell, patterns) => patterns.some((p) => p.test(cell));

  // Detect the header row by scanning the top section for a row containing Item#/Description/etc.
  const headerPatterns = {
    item: [/^item\s*#?$/i, /\bitem\b/i, /\bsku\b/i, /\bitem\s*no\b/i, /\bitem\s*number\b/i],
    desc: [/\bdescription\b/i, /\bproduct\s*name\b/i],
    haz:  [/\bhaz\b/i, /\bhaz\s*class\b/i, /haz[_\s-]*info/i],
    insert: [/\binsert\b/i],
    bottle: [/\bbottle\s*label\b/i, /\blabel\s*id\b/i, /\blabel\b/i],
    box: [/\bbox\s*label\b/i, /\bcase\s*label\b/i],
    closure: [/\bclosure\b/i],
    pack: [/\bpack\b/i]
  };

  let headerRowIdx = -1;
  let headerScoreBest = -1;

  for (let r = 0; r < Math.min(60, aoa.length); r++) {
    const row = aoa[r] || [];
    let nonEmpty = 0;
    let hits = { item: 0, desc: 0, haz: 0, insert: 0, bottle: 0, box: 0, closure: 0, pack: 0 };

    for (let c = 0; c < row.length; c++) {
      const cell = normCell(row[c]);
      if (!cell) continue;
      nonEmpty++;
      for (const k of Object.keys(hits)) {
        if (isMatch(cell, headerPatterns[k])) hits[k]++;
      }
    }

    // Require at least item+description-like signals.
    const hasItem = hits.item > 0;
    const hasDesc = hits.desc > 0;
    if (!hasItem || !hasDesc) continue;

    // Prefer rows with more header hits + many filled cells.
    const score =
      (hits.item + hits.desc) * 50 +
      (hits.haz + hits.insert + hits.bottle + hits.box + hits.closure + hits.pack) * 10 +
      nonEmpty;

    if (score > headerScoreBest) {
      headerScoreBest = score;
      headerRowIdx = r;
    }
  }

  if (headerRowIdx < 0) {
    setSourceStatus('Source sheet loaded, but could not find a header row (expected columns like "Item#", "Description").');
    sourceSearch.disabled = false;
    sourceSearchBtn.disabled = false;
    sourceClearBtn.disabled = false;
    return;
  }

  const headerRow = aoa[headerRowIdx] || [];
  const findCol = (patterns) => {
    for (let c = 0; c < headerRow.length; c++) {
      const cell = normCell(headerRow[c]);
      if (!cell) continue;
      if (isMatch(cell, patterns)) return c;
    }
    return -1;
  };

  const itemCol = findCol(headerPatterns.item);
  const descCol = findCol(headerPatterns.desc);
  const hazCol = findCol(headerPatterns.haz);
  const insertCol = findCol(headerPatterns.insert);
  const bottleCol = findCol([/\bbottle\s*label\b/i, /\bbottle\s*label\s*location\b/i, /\bbottle\s*label\s*loc\b/i, /\blabel\s*location\b/i, /\bbottle\s*label\b/i]);
  const boxCol = findCol([/\bbox\s*label\b/i, /\bbox\s*label\s*location\b/i, /\bcase\s*label\b/i]);
  const closureCol = findCol([/\bclosure\s*type\b/i, /\bclosure\b/i]);
  const packCol = findCol([/\bpack\s*type\b/i, /\bpack\b/i]);

  if (itemCol < 0 || descCol < 0) {
    setSourceStatus('Source sheet header found, but missing Item#/Description columns.');
    sourceSearch.disabled = false;
    sourceSearchBtn.disabled = false;
    sourceClearBtn.disabled = false;
    return;
  }

  const recs = [];
  for (let r = headerRowIdx + 1; r < aoa.length; r++) {
    const row = aoa[r] || [];
    const itemNumber = safeStr(row[itemCol]);
    const description = safeStr(row[descCol]);
    if (!itemNumber && !description) continue;

    const hazInfo = normalizeHaz(hazCol >= 0 ? row[hazCol] : "");
    const insertInfo = safeStr(insertCol >= 0 ? row[insertCol] : "");
    const labelLocation = safeStr(bottleCol >= 0 ? row[bottleCol] : "");
    const boxLabelLocation = safeStr(boxCol >= 0 ? row[boxCol] : "");
    const closureType = safeStr(closureCol >= 0 ? row[closureCol] : "");
    const packType = safeStr(packCol >= 0 ? row[packCol] : "");

    recs.push({
      itemNumber,
      description,
      hazInfo,
      insertInfo,
      labelLocation,
      boxLabelLocation,
      closureType,
      packType,
      _searchText: `${itemNumber} ${description}`.toLowerCase()
    });
  }

  sourceRecords = recs;

  sourceReady = true;
  sourceSearch.disabled = false;
  sourceSearchBtn.disabled = false;
  sourceClearBtn.disabled = false;

  setSourceStatus(`Source loaded (${sourceRecords.length} rows).`);
}

function runSourceSearch() {
  if (!sourceReady) return;
  const q = safeStr(sourceSearch.value);
  if (!q) {
    setSourceStatus(`Source loaded (${sourceRecords.length} rows).`);
    renderSourceResults([]);
    return;
  }

  const needle = q.toLowerCase();
  const hits = sourceRecords.filter(r => r._searchText.includes(needle));
  setSourceStatus(`Found ${hits.length} result(s) for “${q}”.`);
  renderSourceResults(hits);
}

// Event listeners
daySelect.addEventListener("change", () => {
  if (!workbook) return;
  build(); // Auto-build when day sheet changes
});

btnPrint.addEventListener("click", () => { if (cleanRows.length) window.print(); });

sourceSearchBtn.addEventListener("click", runSourceSearch);
sourceSearch.addEventListener("keyup", (e) => { if (e.key === "Enter") runSourceSearch(); });
sourceClearBtn.addEventListener("click", () => {
  sourceSearch.value = "";
  if (!sourceReady) return;
  setSourceStatus(`Source loaded (${sourceRecords.length} rows).`);
  renderSourceResults([]);
  sourceSearch.focus();
});

// Initialize
loadWorkbook();
</script>
</body>
</html>
