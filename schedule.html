<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Production Schedule</title>
  <link rel="icon" type="image/png" href="IMG_0274.png">
  <link rel="apple-touch-icon" href="IMG_0274.png">
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root{
      --bg:#f5f7fa;
      --panel:#ffffff;
      --text:#2d3748;
      --muted:#718096;
      --accent:#3182ce;
      --accent-dark:#2c5282;
      --border:#e2e8f0;
      --line-accent:#4299e1;
      --line-bg:#ebf8ff;
      --hover:#f7fafc;

      /* High-contrast schedule header badges (screen + print) */
      --date-bg:#fde047;          /* amber */
      --date-border:#f59e0b;
      --date-text:#111827;

      --shift-first-bg:#86efac;   /* green */
      --shift-first-border:#22c55e;
      --shift-first-text:#064e3b;

      --shift-second-bg:#c4b5fd;  /* violet */
      --shift-second-border:#8b5cf6;
      --shift-second-text:#312e81;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:"Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background:var(--bg);
      color:var(--text);
      line-height:1.6;
    }
    header{
      padding:28px 40px;
      background:linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
      color:white;
      box-shadow:0 4px 6px rgba(0,0,0,.1);
      position:sticky; top:0; z-index:10;
    }
    .header-content{
      display:flex;
      justify-content:space-between;
      align-items:center;
      flex-wrap:wrap;
      gap:20px;
      max-width:1600px;
      margin:0 auto;
    }
    header h1{
      margin:0; 
      font-size:28px; 
      font-weight:700; 
      letter-spacing:-0.8px;
      text-shadow:0 2px 4px rgba(0,0,0,.1);
    }
    .schedule-info{
      display:flex;
      align-items:center;
      gap:16px;
      flex-wrap:wrap;
    }
    .schedule-date{
      font-size:18px;
      color:var(--date-text);
      font-weight:800;
      background:var(--date-bg);
      padding:10px 16px;
      border-radius:999px;
      border:2px solid var(--date-border);
      box-shadow:0 4px 10px rgba(0,0,0,.18);
      letter-spacing:-0.2px;
    }
    .shift-badge{
      display:inline-flex;
      align-items:center;
      padding:10px 16px;
      border-radius:999px;
      font-size:15px;
      font-weight:800;
      border:2px solid transparent;
      box-shadow:0 4px 10px rgba(0,0,0,.18);
      letter-spacing:-0.2px;
      background:var(--shift-second-bg);
      border-color:var(--shift-second-border);
      color:var(--shift-second-text);
      white-space:nowrap;
    }
    .shift-badge[data-shift="First Shift"]{
      background:var(--shift-first-bg);
      border-color:var(--shift-first-border);
      color:var(--shift-first-text);
    }
    .shift-badge[data-shift="Second Shift"]{
      background:var(--shift-second-bg);
      border-color:var(--shift-second-border);
      color:var(--shift-second-text);
    }
    main{
      padding:32px 40px;
      max-width:1600px;
      margin:0 auto;
    }
    .panel{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:12px;
      padding:24px;
      box-shadow:0 2px 8px rgba(0,0,0,.06);
      margin-bottom:24px;
    }
    .controls{
      display:flex;
      justify-content:flex-start;
      align-items:center;
      flex-wrap:wrap;
      gap:12px;
      padding:20px;
      background:linear-gradient(to right, #f8fafc, #f1f5f9);
      border-radius:10px;
      border:1px solid var(--border);
    }
    select, button{
      border:1px solid var(--border);
      background:white;
      color:var(--text);
      border-radius:8px;
      padding:11px 18px;
      outline:none;
      font-size:14px;
      transition:all 0.2s ease;
      font-weight:500;
      box-shadow:0 1px 2px rgba(0,0,0,.05);
    }
    input{
      border:1px solid var(--border);
      background:white;
      color:var(--text);
      border-radius:8px;
      padding:11px 18px;
      outline:none;
      font-size:14px;
      transition:all 0.2s ease;
      font-weight:500;
      box-shadow:0 1px 2px rgba(0,0,0,.05);
      min-width:320px;
    }
    select{
      min-width:240px;
      cursor:pointer;
      appearance:none;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%233182ce' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
      background-repeat:no-repeat;
      background-position:right 14px center;
      padding-right:40px;
    }
    select:hover, select:focus{
      border-color:var(--accent);
      box-shadow:0 0 0 3px rgba(49,130,206,.1);
    }
    input:hover, input:focus{
      border-color:var(--accent);
      box-shadow:0 0 0 3px rgba(49,130,206,.1);
    }
    button{
      cursor:pointer;
      user-select:none;
      background:var(--accent);
      color:white;
      border-color:var(--accent);
      font-weight:600;
      padding:11px 24px;
    }
    button:hover{
      background:var(--accent-dark);
      border-color:var(--accent-dark);
      transform:translateY(-1px);
      box-shadow:0 4px 6px rgba(0,0,0,.1);
    }
    button:active{transform: translateY(0)}
    button:disabled{
      opacity:0.5;
      cursor:not-allowed;
      background:#cbd5e0;
      border-color:#cbd5e0;
    }
    .tableWrap{
      overflow:auto;
      border-radius:8px;
      border:1px solid var(--border);
      margin-top:16px;
      box-shadow:inset 0 2px 4px rgba(0,0,0,.04);
    }
    table{
      border-collapse:collapse;
      width:100%;
      min-width:700px;
      background:white;
    }
    th, td{
      border-bottom:1px solid var(--border);
      padding:14px 16px;
      text-align:left;
      font-size:13px;
    }
    th{
      position:sticky;
      top:0;
      background:#f8fafc;
      z-index:2;
      font-size:12px;
      color:var(--muted);
      font-weight:700;
      text-transform:uppercase;
      letter-spacing:0.8px;
      border-bottom:2px solid var(--accent);
      color:var(--accent);
    }
    tr:hover td{
      background:var(--hover);
    }
    .line-header{
      background:var(--line-bg) !important;
      font-weight:700;
      color:var(--accent-dark) !important;
      font-size:14px;
      padding:16px;
    }
    .line-header td{
      border-bottom:3px solid var(--line-accent);
      font-size:15px;
    }

    .label-pickable{
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      padding:6px 10px;
      border-radius:6px;
      transition: background-color 160ms ease, color 160ms ease, text-decoration-color 160ms ease;
      text-decoration: underline;
      text-decoration-color: transparent;
      text-underline-offset: 3px;
      display:inline-block;
      min-width:60px;
      text-align:center;
      font-weight:500;
      touch-action:manipulation;
    }
    .label-picked{
      background: rgba(34, 197, 94, 0.2); /* green */
      color: #166534;
      text-decoration-color: rgba(22, 101, 52, 0.85);
      font-weight:600;
    }
    .label-pickable:hover{
      background:rgba(49, 130, 206, 0.1);
    }
    .picking-instructions{
      background:linear-gradient(to right, #e0f2fe, #dbeafe);
      border-left:4px solid var(--accent);
      padding:16px 20px;
      border-radius:8px;
      margin-bottom:20px;
      font-size:14px;
      line-height:1.7;
    }
    .picking-instructions h3{
      margin:0 0 8px 0;
      font-size:16px;
      color:var(--accent-dark);
      display:flex;
      align-items:center;
      gap:8px;
    }
    .picking-instructions ul{
      margin:8px 0 0 0;
      padding-left:20px;
    }
    .picking-instructions li{
      margin:4px 0;
    }
    .progress-summary{
      display:flex;
      gap:16px;
      flex-wrap:wrap;
      margin-bottom:20px;
      padding:16px;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:8px;
    }
    .progress-item{
      flex:1;
      min-width:150px;
      padding:12px;
      background:var(--hover);
      border-radius:6px;
      text-align:center;
    }
    .progress-item .label{
      font-size:12px;
      color:var(--muted);
      font-weight:600;
      text-transform:uppercase;
      letter-spacing:0.5px;
      margin-bottom:4px;
    }
    .progress-item .value{
      font-size:24px;
      font-weight:700;
      color:var(--accent);
    }
    .progress-item .subtext{
      font-size:11px;
      color:var(--muted);
      margin-top:4px;
    }
    .bottle-qty-calc{
      font-size:11px;
      color:var(--muted);
      margin-top:4px;
      font-style:italic;
    }
    .bottle-qty-calc strong{
      color:var(--accent);
      font-weight:600;
    }
    .haz-badge{
      display:inline-block;
      padding:4px 8px;
      background:#fef3c7;
      color:#92400e;
      border-radius:4px;
      font-size:11px;
      font-weight:600;
      margin-left:6px;
    }
    .label-pickable .haz-badge{
      margin-left:8px;
    }
    .help-icon{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:18px;
      height:18px;
      border-radius:50%;
      background:rgba(49, 130, 206, 0.15);
      color:var(--accent);
      font-size:11px;
      font-weight:700;
      cursor:help;
      margin-left:6px;
      vertical-align:middle;
    }
    @media (max-width: 768px) {
      .progress-summary{
        flex-direction:column;
      }
      .progress-item{
        min-width:100%;
      }
      .label-pickable{
        padding:8px 12px;
        font-size:14px;
      }
    }

    .small{font-size:11px;color:var(--muted)}
    .footer-info{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-top:2rem;
      padding-top:1.5rem;
      border-top:1px solid var(--border);
    }
    .footer-info img{
      height:50px;
      opacity:0.9;
    }
    .footer-nav{
      display:flex;
      align-items:center;
      gap:16px;
    }
    .footer-nav a{
      color:var(--accent);
      text-decoration:none;
      font-weight:500;
      font-size:13px;
      transition:color 0.2s ease;
    }
    .footer-nav a:hover{
      color:var(--accent-dark);
      text-decoration:underline;
    }
    .printTitle{display:none}
    .printHeader{display:none}
    @page{
      size: letter landscape;
      margin:0.5in;
    }
    @media print{
      *{margin:0; padding:0; box-sizing:border-box}
      html, body{
        width:100%;
        height:100%;
        margin:0;
        padding:0;
        background:var(--bg);
        color:var(--text);
        overflow:visible;
        -webkit-print-color-adjust:exact;
        print-color-adjust:exact;
      }
      header, .controls, .status, .footer-info{display:none !important}
      .source-panel{display:none !important}
      .picking-instructions{display:none !important}
      .progress-summary{display:none !important}
      .help-icon{display:none !important}
      .haz-badge{display:none !important}
      main{
        padding:0;
        margin:0;
        width:100%;
        height:100%;
      }
      .schedule-panel{
        border:none;
        box-shadow:none;
        background:transparent;
        padding:0;
        margin:0;
        width:100%;
        height:100%;
        display:flex;
        flex-direction:column;
      }
      .printHeader{
        display:flex !important;
        justify-content:space-between;
        align-items:center;
        margin-bottom:12px;
        padding-bottom:8px;
        border-bottom:1px solid var(--border);
        width:100%;
      }
      .printTitle{
        display:block !important;
        margin:0 0 4px 0;
        font-size:18px;
        font-weight:600;
        color:var(--text);
      }
      .printHeader .printDate{
        display:inline-flex;
        align-items:center;
        font-size:14px;
        font-weight:800;
        color:var(--date-text);
        background:var(--date-bg);
        border:2px solid var(--date-border);
        padding:6px 12px;
        border-radius:999px;
        letter-spacing:-0.1px;
      }
      .printHeader .printShift{
        display:inline-flex;
        align-items:center;
        padding:6px 12px;
        border-radius:999px;
        font-size:13px;
        font-weight:800;
        background:var(--shift-second-bg);
        border:2px solid var(--shift-second-border);
        color:var(--shift-second-text);
        letter-spacing:-0.1px;
      }
      .printHeader .printShift[data-shift="First Shift"]{
        background:var(--shift-first-bg);
        border-color:var(--shift-first-border);
        color:var(--shift-first-text);
      }
      .printHeader .printShift[data-shift="Second Shift"]{
        background:var(--shift-second-bg);
        border-color:var(--shift-second-border);
        color:var(--shift-second-text);
      }
      .tableWrap{
        border:none;
        overflow:visible;
        flex:1;
        width:100%;
      }
      table{
        background:white;
        width:100%;
        min-width:0;
        font-size:11px;
      }
      th{
        background:#f8fafc;
        color:#4a5568;
        border-bottom:1px solid #cbd5e0;
        padding:6px 8px;
        font-size:11px;
        position:static;
      }
      td{
        border-bottom:1px solid #e2e8f0;
        color:#111827;
        padding:6px 8px;
        font-size:11px;
      }
      /* Show bottle label quantity under Ordered QTY when printing */
      .bottle-qty-calc{
        display:block !important;
        margin-top:2px !important;
        font-size:10px !important;
        color:#374151 !important;
        font-style:italic;
      }
      .bottle-qty-calc strong{
        color:#111827 !important;
        font-weight:700;
      }
      /* Keep print identical to pre-highlight look */
      .label-pickable{
        padding:0 !important;
        border-radius:0 !important;
        background:transparent !important;
        color:inherit !important;
        text-decoration:none !important;
      }
      .label-picked{
        background:transparent !important;
        color:inherit !important;
        text-decoration:none !important;
      }
      .line-header{
        background:#ebf8ff !important;
        color:#1e3a8a !important;
      }
      .line-header td{
        border-bottom:2px solid rgba(66,153,225,.6);
        padding:8px;
        font-weight:600;
      }
    }
  </style>
</head>
<body>
<header>
  <div class="header-content">
    <h1>Production Schedule</h1>
    <div class="schedule-info">
      <span class="schedule-date" id="scheduleDate">â€”</span>
      <span class="shift-badge" id="shiftBadge">â€”</span>
    </div>
  </div>
</header>

<main>
  <div class="panel controls">
    <label for="daySelect" style="font-weight:600; color:var(--text); font-size:14px; margin-right:4px;">Select Schedule:</label>
    <select id="daySelect" disabled></select>
    <button id="btnPrint" disabled>Print</button>
    <button id="btnClearPicked" disabled style="background:#dc2626;border-color:#dc2626;">Clear All Picked</button>
  </div>

  <div class="panel schedule-panel">
    <div class="picking-instructions">
      <h3>ðŸ“‹ Label Picking Instructions</h3>
      <ul>
        <li><strong>Tap</strong> the label location to mark it as picked (turns green)</li>
        <li><strong>Bottle Labels:</strong> Multiply case quantity by pack type (shown below each order)</li>
        <li><strong>Haz Labels:</strong> Pick if Haz Info is shown (corrosive label)</li>
        <li><strong>Progress:</strong> Track your progress with the summary above</li>
        <li><strong>Search:</strong> Use "Search Source" below to find label locations for rollover items</li>
      </ul>
    </div>
    
    <div class="progress-summary" id="progressSummary" style="display:none;">
      <div class="progress-item">
        <div class="label">Total Items</div>
        <div class="value" id="progressTotal">0</div>
      </div>
      <div class="progress-item">
        <div class="label">Bottle Labels Picked</div>
        <div class="value" id="progressBottle">0</div>
        <div class="subtext" id="progressBottlePct">0%</div>
      </div>
      <div class="progress-item">
        <div class="label">Box Labels Picked</div>
        <div class="value" id="progressBox">0</div>
        <div class="subtext" id="progressBoxPct">0%</div>
      </div>
      <div class="progress-item">
        <div class="label">Haz Labels Picked</div>
        <div class="value" id="progressHaz">0</div>
        <div class="subtext" id="progressHazPct">0%</div>
      </div>
    </div>
    
    <div class="printHeader">
      <div>
        <h2 class="printTitle" id="printTitle" style="margin:0 0 4px 0; font-size:16px;">
          Production Schedule
        </h2>
        <span class="printDate" id="printDate">â€”</span>
      </div>
      <span class="printShift" id="printShift">â€”</span>
    </div>
    <div class="tableWrap">
      <table id="cleanTable">
        <thead>
          <tr>
            <th>Description</th>
            <th>SKU#</th>
            <th>Ordered QTY</th>
            <th>Haz Info <span class="help-icon" title="Tap to mark as picked">?</span></th>
            <th>Bottle Label Location <span class="help-icon" title="Tap to mark as picked. Quantity shown below.">?</span></th>
            <th>Box Label Location <span class="help-icon" title="Tap to mark as picked">?</span></th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div class="panel source-panel">
    <div style="display:flex; justify-content:space-between; align-items:flex-end; gap:16px; flex-wrap:wrap;">
      <div>
        <div style="font-weight:700; font-size:16px; margin-bottom:4px;">Search Source</div>
        <div class="small">Search by Item Number or Description (from the <strong>Source</strong> tab).</div>
      </div>
      <div class="small" id="sourceSearchStatus" style="text-align:right;">Loadingâ€¦</div>
    </div>

    <div class="controls" style="margin-top:16px;">
      <input id="sourceSearch" type="text" placeholder="Type item number or descriptionâ€¦" disabled />
      <button id="sourceSearchBtn" disabled>Search</button>
      <button id="sourceClearBtn" disabled style="background:white;color:var(--accent);border-color:var(--border);">Clear</button>
    </div>

    <div class="tableWrap">
      <table id="sourceResultsTable">
        <thead>
          <tr>
            <th>Item #</th>
            <th>Description</th>
            <th>Haz Info</th>
            <th>Insert Info</th>
            <th>Label Location</th>
            <th>Box Label Location</th>
            <th>Closure Type</th>
            <th>Pack Type</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div class="footer-info">
    <div>
      <div class="muted" style="font-size:13px;">App made by <strong>J.L.</strong></div>
      <div class="footer-nav" style="margin-top:8px;">
        <a href="index.html">Product Weight Calculator</a>
      </div>
    </div>
    <img src="maintex-logo.jpg" alt="Maintex Logo">
  </div>
</main>

<script>
// XLSX workbook to load (must be served alongside this page).
// Note: the actual filename contains spaces, so we URI-encode it for fetch().
const XLSX_FILE_PATH = encodeURI("Production Schedule Q1-Q2 2026.xlsx");

// State
let workbook = null;
let allSheetNames = [];
let sheetNames = []; // schedule day sheets only (for dropdown)
let cleanRows = [];
let sourceRecords = [];
let sourceReady = false;

// DOM
const $ = (id) => document.getElementById(id);
const daySelect = $("daySelect");
const btnPrint = $("btnPrint");
const scheduleDate = $("scheduleDate");
const shiftBadge = $("shiftBadge");
const cleanTable = $("cleanTable");
const sourceSearch = $("sourceSearch");
const sourceSearchBtn = $("sourceSearchBtn");
const sourceClearBtn = $("sourceClearBtn");
const sourceResultsTable = $("sourceResultsTable");
const sourceSearchStatus = $("sourceSearchStatus");

// Helpers
function normalizeHeader(s) {
  return String(s ?? "").trim().toLowerCase().replace(/\s+/g," ");
}

function looksLikeSku(value) {
  const v = String(value ?? "").trim();
  return v.length >= 3 && /^[A-Za-z0-9\-_\.]+$/.test(v);
}

function parseNumber(value) {
  if (value == null || value === "") return null;
  if (typeof value === "number" && isFinite(value)) return value;
  const v = String(value).replace(/,/g,"").trim();
  const n = Number(v);
  return isFinite(n) ? n : null;
}

function isPriority(value) {
  return /^[A-E]$/.test(String(value ?? "").trim().toUpperCase());
}

function safeStr(v) {
  return v == null ? "" : String(v).trim();
}

function pickSheetByNameLike(names, needle) {
  const n = needle.toLowerCase();
  return names.find(s => s.toLowerCase().includes(n));
}

function norm(s) {
  return String(s ?? "").trim().toLowerCase();
}

function lineNumberFromLabel(lineLabel) {
  const m = String(lineLabel ?? "").match(/(\d+)/);
  return m ? parseInt(m[1], 10) : null;
}

function uomForScheduleRow(row) {
  const lineNum = lineNumberFromLabel(row.Line);
  if ([1, 2, 3, 4, 6, 7].includes(lineNum)) return "CS";
  if (lineNum === 5) {
    const d = String(row.Description ?? "").toLowerCase();
    // Best-effort separation for Line 5
    if (d.includes("drum") || /\bdr\b/.test(d)) return "DR";
    if (d.includes("pail") || /\bpl\b/.test(d)) return "PL";
    return "EA";
  }
  return "";
}

function hashKey(str) {
  // FNV-1a 32-bit
  let h = 0x811c9dc5;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 0x01000193);
  }
  return (h >>> 0).toString(36);
}

function pickedStorageKey(dayName, row, kind) {
  const raw = `${dayName}|${row.Line}|${row["SKU#"]}|${row.Description}|${kind}`;
  return `maintex:schedule:picked:v1:${hashKey(raw)}`;
}

function isPicked(dayName, row, kind) {
  try {
    return localStorage.getItem(pickedStorageKey(dayName, row, kind)) === "1";
  } catch {
    return false;
  }
}

function setPicked(dayName, row, kind, picked) {
  try {
    localStorage.setItem(pickedStorageKey(dayName, row, kind), picked ? "1" : "0");
  } catch {
    // ignore storage failures
  }
}

// Get today's date in MM-DD format for sheet matching
function getTodaySheetFormat() {
  const today = new Date();
  const month = String(today.getMonth() + 1).padStart(2, '0');
  const day = String(today.getDate()).padStart(2, '0');
  return `${month}-${day}`;
}

// Detect shift from sheet name or data
function detectShift(sheetName, dayAoa) {
  const nameLower = sheetName.toLowerCase();
  
  // Workbook convention: "MM-DD" (first shift) vs "MM-DD PM"/"MM-DDpm" (second shift)
  if (/\bpm\b/i.test(sheetName) || /pm$/i.test(sheetName.trim())) {
    return 'Second Shift';
  }
  
  // Check first few rows of data for shift indicators
  for (let r = 0; r < Math.min(20, dayAoa.length); r++) {
    const row = dayAoa[r] || [];
    const rowText = row.join(' ').toLowerCase();
    if (rowText.includes('first shift') || rowText.includes('1st shift')) {
      return 'First Shift';
    }
    if (rowText.includes('second shift') || rowText.includes('2nd shift') || rowText.includes('pm')) {
      return 'Second Shift';
    }
  }
  
  // Default to First Shift if not detected
  return 'First Shift';
}

// Format date from sheet name (e.g., "01-05" -> "Friday, January 5")
function formatScheduleDate(sheetName) {
  const match = sheetName.match(/(\d{1,2})-(\d{1,2})/);
  if (match) {
    const month = parseInt(match[1]);
    const day = parseInt(match[2]);
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                       'July', 'August', 'September', 'October', 'November', 'December'];
    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    
    if (month >= 1 && month <= 12) {
      // Try to determine year - check if workbook name has year, otherwise use current year
      let year = new Date().getFullYear();
      const workbookYearMatch = XLSX_FILE_PATH.match(/202[4-9]/);
      if (workbookYearMatch) {
        year = parseInt(workbookYearMatch[0]);
      }
      
      // Create date object to get day of week
      const date = new Date(year, month - 1, day);
      const dayOfWeek = dayNames[date.getDay()];
      
      return `${dayOfWeek}, ${monthNames[month - 1]} ${day}, ${year}`;
    }
  }
  return sheetName;
}

// Check if a sheet exists for a given date
function sheetExistsForDate(names, month, day) {
  const formats = [
    `${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`, // "01-03"
    `${month}-${day}`, // "1-3"
    `${String(month).padStart(2, '0')}-${day}`, // "01-3"
    `${month}-${String(day).padStart(2, '0')}` // "1-03"
  ];
  
  return names.find(s => {
    const trimmed = s.trim();
    return formats.some(format => 
      trimmed === format || trimmed.startsWith(format)
    );
  });
}

// Find sheet matching today's date or next available workday
function findTodaySheet(names) {
  const today = new Date();
  let checkDate = new Date(today);
  const maxDaysAhead = 14; // Look up to 2 weeks ahead
  let daysChecked = 0;
  
  while (daysChecked < maxDaysAhead) {
    const month = checkDate.getMonth() + 1;
    const day = checkDate.getDate();
    const dayOfWeek = checkDate.getDay(); // 0 = Sunday, 6 = Saturday
    
    // Skip weekends - if Saturday, jump to Monday; if Sunday, jump to Monday
    if (dayOfWeek === 6) { // Saturday
      checkDate.setDate(checkDate.getDate() + 2); // Jump to Monday
      daysChecked += 2;
      continue;
    }
    if (dayOfWeek === 0) { // Sunday
      checkDate.setDate(checkDate.getDate() + 1); // Jump to Monday
      daysChecked += 1;
      continue;
    }
    
    // Check if sheet exists for this date
    const match = sheetExistsForDate(names, month, day);
    if (match) {
      return match;
    }
    
    // Move to next day
    checkDate.setDate(checkDate.getDate() + 1);
    daysChecked++;
  }
  
  // If no match found after checking ahead, return null
  return null;
}

// Extract pack type (bottles per case) from description only
// Patterns: "4PK", "4/64oz", "4/64 oz", "6/cs", "2PK", "4/1", "4/64", etc.
function extractBottlesPerCase(description) {
  if (!description) return null;
  const desc = String(description).trim();
  
  // Pattern 1: XPK (e.g., "4PK", "2PK", "12PK") - X bottles per case
  // Also match "4 PK" with space
  const pkMatch = desc.match(/(\d+)\s*PK/i);
  if (pkMatch) {
    return parseInt(pkMatch[1], 10);
  }
  
  // Pattern 2: X/cs or X/CS or X/CS or X per case (e.g., "6/cs", "4/CS", "4 per case")
  const csMatch = desc.match(/(\d+)\s*\/\s*cs/i) || desc.match(/(\d+)\s+per\s+case/i);
  if (csMatch) {
    return parseInt(csMatch[1], 10);
  }
  
  // Pattern 3: X/Yoz or X/Y oz (e.g., "4/64oz", "4/64 oz", "2/32oz", "4/64OZ", "4-64oz")
  // This means X bottles per case, Y is the bottle size in oz
  // Also match with dash: "4-64oz"
  const ozMatch = desc.match(/(\d+)\s*[-\/]\s*(\d+)\s*(oz|OZ|fl\s*oz|ml|liter|gal|gallon)/i);
  if (ozMatch) {
    const num = parseInt(ozMatch[1], 10);
    if (num >= 1 && num <= 24) return num;
  }
  
  // Pattern 4: X/Y where Y is a number (could be size or cases)
  // Try to be smart: if Y >= 8, likely a size (e.g., "4/64" = 4 bottles of 64oz)
  // If Y = 1, it's X/1 CS format = X bottles per case
  // Also match with dash: "4-64"
  const numMatch = desc.match(/(\d+)\s*[-\/]\s*(\d+)(?!\s*(oz|OZ|fl|ml|liter|gal|gallon|cs|pk|PK|per))/i);
  if (numMatch) {
    const first = parseInt(numMatch[1], 10);
    const second = parseInt(numMatch[2], 10);
    
    // If second number is 1, it's X/1 CS format = X bottles per case
    if (second === 1 && first >= 1 && first <= 24) {
      return first;
    }
    
    // If second number is >= 8, likely a size (e.g., "4/64" = 4 bottles of 64oz per case)
    // Common sizes: 8oz, 16oz, 32oz, 64oz, 128oz, etc.
    if (second >= 8 && first >= 1 && first <= 24) {
      return first;
    }
    
    // If first is 1-12 and second is 2-7, check context
    // If no "case" or "cs" context, likely size format
    if (first >= 1 && first <= 12 && second >= 2 && second <= 7) {
      const context = desc.toLowerCase();
      // If there's no case/cs/pack context, treat as size (e.g., "4/32" = 4 bottles of 32oz)
      if (!context.includes('case') && !context.includes('cs') && !context.includes('pack')) {
        return first;
      }
    }
  }
  
  // Pattern 5: Look for common pack type indicators in the description
  // e.g., "4 pack", "6 pack", "12 pack" (though these are usually consumer packs)
  // But also "4/1", "6/1" might appear as "4-1" or "4 1"
  const packMatch = desc.match(/(\d+)\s*[- ]\s*1\s*(?:cs|case|pack)/i) || 
                    desc.match(/(\d+)\s*\/\s*1\s*(?:cs|case|pack)/i);
  if (packMatch) {
    return parseInt(packMatch[1], 10);
  }
  
  // Pattern 6: Just a number followed by certain keywords (e.g., "4 bottles", "6 per")
  // This is less reliable, so we'll be conservative
  const bottleMatch = desc.match(/(\d+)\s+(?:bottles?|per)/i);
  if (bottleMatch) {
    const num = parseInt(bottleMatch[1], 10);
    // Only accept if it's a reasonable number (1-24)
    if (num >= 1 && num <= 24) {
      return num;
    }
  }
  
  return null;
}

// Calculate bottle label quantity from description only
function calculateBottleLabels(caseQty, description) {
  if (!caseQty || !description) return null;
  
  const bottlesPerCase = extractBottlesPerCase(description);
  
  // Debug: log when we can't find pack type (temporary for troubleshooting)
  if (!bottlesPerCase && caseQty && String(description).trim()) {
    console.log('âš  No pack type found for:', description, '| Case Qty:', caseQty);
  }
  
  if (!bottlesPerCase) return null;
  
  const caseNum = typeof caseQty === 'number' ? caseQty : parseFloat(String(caseQty).replace(/,/g, ''));
  if (!isFinite(caseNum)) return null;
  
  return caseNum * bottlesPerCase;
}

// Update progress summary
function updateProgressSummary(rows, dayName) {
  const summary = document.getElementById("progressSummary");
  if (!summary) return;
  
  if (rows.length === 0) {
    summary.style.display = "none";
    return;
  }
  
  summary.style.display = "flex";
  
  let totalItems = rows.length;
  let bottlePicked = 0;
  let boxPicked = 0;
  let hazNeeded = 0;
  let hazPicked = 0;
  
  for (const row of rows) {
    if (isPicked(dayName, row, "bottle")) bottlePicked++;
    if (isPicked(dayName, row, "box")) boxPicked++;
    if (row.Haz_Info && String(row.Haz_Info).trim() !== "") {
      hazNeeded++;
      if (isPicked(dayName, row, "haz")) hazPicked++;
    }
  }
  
  const bottlePct = totalItems > 0 ? Math.round((bottlePicked / totalItems) * 100) : 0;
  const boxPct = totalItems > 0 ? Math.round((boxPicked / totalItems) * 100) : 0;
  const hazPct = hazNeeded > 0 ? Math.round((hazPicked / hazNeeded) * 100) : 0;
  
  document.getElementById("progressTotal").textContent = totalItems;
  document.getElementById("progressBottle").textContent = `${bottlePicked} / ${totalItems}`;
  document.getElementById("progressBottlePct").textContent = `${bottlePct}% complete`;
  document.getElementById("progressBox").textContent = `${boxPicked} / ${totalItems}`;
  document.getElementById("progressBoxPct").textContent = `${boxPct}% complete`;
  document.getElementById("progressHaz").textContent = `${hazPicked} / ${hazNeeded}`;
  const hazPctEl = document.getElementById("progressHazPct");
  if (hazPctEl) {
    hazPctEl.textContent = hazNeeded > 0 ? `${hazPct}% complete` : "";
  }
}

// Render clean table grouped by Line
function renderCleanRows(rows, dayName) {
  const tbody = cleanTable.querySelector("tbody");
  tbody.innerHTML = "";
  if (rows.length === 0) {
    tbody.innerHTML = '<tr><td colspan="6" style="text-align:center;padding:40px;color:var(--muted)">No schedule data found.</td></tr>';
    updateProgressSummary([], dayName);
    return;
  }
  
  // Group rows by Line
  const groupedByLine = new Map();
  for (const row of rows) {
    const line = row.Line || "Unknown";
    if (!groupedByLine.has(line)) {
      groupedByLine.set(line, []);
    }
    groupedByLine.get(line).push(row);
  }
  
  // Sort lines (Line #1, Line #2, etc.)
  const sortedLines = Array.from(groupedByLine.keys()).sort((a, b) => {
    const numA = parseInt(a.match(/\d+/)?.[0] || "999");
    const numB = parseInt(b.match(/\d+/)?.[0] || "999");
    return numA - numB;
  });
  
  // Render each line group
  for (const line of sortedLines) {
    const lineRows = groupedByLine.get(line);
    
    // Add Line header row
    const headerTr = document.createElement("tr");
    headerTr.className = "line-header";
    const headerTd = document.createElement("td");
    headerTd.colSpan = 6;
    headerTd.textContent = line;
    headerTr.appendChild(headerTd);
    tbody.appendChild(headerTr);
    
    // Add data rows for this line
    for (const row of lineRows) {
      const tr = document.createElement("tr");
      const uom = uomForScheduleRow(row);
      const ord = row.Ordered == null ? "" : String(row.Ordered);
      const ordNum = parseNumber(row.Ordered);

      // Description
      const tdDesc = document.createElement("td");
      tdDesc.textContent = row.Description ?? "";
      tr.appendChild(tdDesc);

      // SKU#
      const tdSku = document.createElement("td");
      tdSku.textContent = row["SKU#"] ?? "";
      tr.appendChild(tdSku);

      // Ordered (UOM) with bottle quantity calculation
      const tdOrd = document.createElement("td");
      const ordText = ord ? (uom ? `${ord} ${uom}` : ord) : "";
      tdOrd.textContent = ordText;
      
      // Add bottle label calculation from description only
      const bottleQty = calculateBottleLabels(ordNum, row.Description);
      if (bottleQty && uom === "CS") {
        const calcDiv = document.createElement("div");
        calcDiv.className = "bottle-qty-calc";
        calcDiv.innerHTML = `<strong>${bottleQty}</strong> bottle labels needed`;
        tdOrd.appendChild(calcDiv);
      }
      tr.appendChild(tdOrd);

      // Haz_Info with badge (tap to toggle picked highlight)
      const tdHaz = document.createElement("td");
      if (row.Haz_Info && String(row.Haz_Info).trim() !== "") {
        const hazContainer = document.createElement("span");
        hazContainer.className = "label-pickable";
        hazContainer.setAttribute("role", "button");
        hazContainer.setAttribute("tabindex", "0");
        hazContainer.setAttribute("aria-label", "Toggle haz label picked");
        
        const hazText = document.createElement("span");
        hazText.textContent = row.Haz_Info;
        hazContainer.appendChild(hazText);
        
        const hazBadge = document.createElement("span");
        hazBadge.className = "haz-badge";
        hazBadge.textContent = "âš  HAZ";
        hazBadge.title = "Hazardous material - pick corrosive label";
        hazContainer.appendChild(hazBadge);
        
        const hazApply = () => {
          const picked = isPicked(dayName, row, "haz");
          hazContainer.classList.toggle("label-picked", picked);
        };
        hazApply();
        
        const hazToggle = () => {
          const next = !isPicked(dayName, row, "haz");
          setPicked(dayName, row, "haz", next);
          hazContainer.classList.toggle("label-picked", next);
          updateProgressSummary(rows, dayName);
        };
        
        hazContainer.addEventListener("click", hazToggle);
        hazContainer.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            hazToggle();
          }
        });
        
        tdHaz.appendChild(hazContainer);
      }
      tr.appendChild(tdHaz);

      // Bottle Label Location (tap to toggle picked highlight)
      const tdBottle = document.createElement("td");
      const bottleSpan = document.createElement("span");
      bottleSpan.className = "label-pickable";
      bottleSpan.textContent = row["Bottle Label Location"] ?? "";
      bottleSpan.setAttribute("role", "button");
      bottleSpan.setAttribute("tabindex", "0");
      bottleSpan.setAttribute("aria-label", "Toggle bottle label picked");
      const bottleApply = () => {
        const picked = isPicked(dayName, row, "bottle");
        bottleSpan.classList.toggle("label-picked", picked);
      };
      bottleApply();
      const bottleToggle = () => {
        const next = !isPicked(dayName, row, "bottle");
        setPicked(dayName, row, "bottle", next);
        bottleSpan.classList.toggle("label-picked", next);
        updateProgressSummary(rows, dayName);
      };
      bottleSpan.addEventListener("click", bottleToggle);
      bottleSpan.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          bottleToggle();
        }
      });
      tdBottle.appendChild(bottleSpan);
      tr.appendChild(tdBottle);

      // Box Label Location (tap to toggle picked highlight)
      const tdBox = document.createElement("td");
      const boxSpan = document.createElement("span");
      boxSpan.className = "label-pickable";
      boxSpan.textContent = row["Box Label Location"] ?? "";
      boxSpan.setAttribute("role", "button");
      boxSpan.setAttribute("tabindex", "0");
      boxSpan.setAttribute("aria-label", "Toggle box label picked");
      const boxApply = () => {
        const picked = isPicked(dayName, row, "box");
        boxSpan.classList.toggle("label-picked", picked);
      };
      boxApply();
      const boxToggle = () => {
        const next = !isPicked(dayName, row, "box");
        setPicked(dayName, row, "box", next);
        boxSpan.classList.toggle("label-picked", next);
        updateProgressSummary(rows, dayName);
      };
      boxSpan.addEventListener("click", boxToggle);
      boxSpan.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          boxToggle();
        }
      });
      tdBox.appendChild(boxSpan);
      tr.appendChild(tdBox);

      tbody.appendChild(tr);
    }
  }
  
  // Update progress summary after rendering
  updateProgressSummary(rows, dayName);
}

// Extract day sheet rows (A=Priority, B=Description, C=SKU, D=Ordered, I=Haz_Info, M=Bottle, N=Box)
// Also extracts Line information by detecting "Line #X" headers or Line column
function extractDayRows(dayAoa) {
  const rows = [];
  let currentLine = null;
  
  // Try to detect if Line is in a specific column (check column E/index 4, or scan for "line" header)
  let lineColIndex = -1;
  for (let r = 0; r < Math.min(10, dayAoa.length); r++) {
    const row = dayAoa[r] || [];
    for (let c = 0; c < row.length; c++) {
      const val = normalizeHeader(safeStr(row[c]));
      if (val.includes("line") && !val.includes("label")) {
        lineColIndex = c;
        break;
      }
    }
    if (lineColIndex >= 0) break;
  }
  // Fallback: try column E (index 4)
  if (lineColIndex < 0) lineColIndex = 4;
  
  for (let r = 0; r < dayAoa.length; r++) {
    const row = dayAoa[r] || [];
    
    // Check ALL cells in this row for a Line header (like "Line #1", "Line 1", etc.)
    let foundLineHeader = false;
    for (let c = 0; c < row.length; c++) {
      const cellValue = safeStr(row[c]);
      // Look for patterns like "Line #1", "Line 1", "Line1", "LINE 1", etc.
      const lineMatch = cellValue.match(/line\s*#?\s*(\d+)/i);
      if (lineMatch) {
        currentLine = `Line #${lineMatch[1]}`;
        foundLineHeader = true;
        break;
      }
    }
    
    // Also check the detected Line column for a line number
    if (!foundLineHeader && lineColIndex >= 0) {
      const lineCellValue = safeStr(row[lineColIndex] || "");
      // Check if it's just a number (like "1", "2") or "Line #1" format
      if (lineCellValue) {
        const numMatch = lineCellValue.match(/(\d+)/);
        if (numMatch && lineCellValue.trim().length < 10) {
          // Likely a line number
          currentLine = `Line #${numMatch[1]}`;
        } else {
          const lineMatch = lineCellValue.match(/line\s*#?\s*(\d+)/i);
          if (lineMatch) {
            currentLine = `Line #${lineMatch[1]}`;
          }
        }
      }
    }
    
    // If we found a Line header row (row with only Line info, no Priority/SKU), skip it
    if (foundLineHeader) {
      const priority = safeStr(row[0]).toUpperCase();
      const sku = safeStr(row[2]);
      // Only skip if it's NOT a valid schedule row
      if (!isPriority(priority) || !looksLikeSku(sku)) {
        continue;
      }
    }
    
    // Now check if this is a valid schedule row
    const priority = safeStr(row[0]).toUpperCase();
    const sku = safeStr(row[2]);
    
    // Skip if not a valid schedule row
    if (!isPriority(priority) || !looksLikeSku(sku)) continue;
    
    // Skip if we haven't found a Line yet (rows before first Line header)
    if (!currentLine) continue;

    rows.push({
      Line: currentLine,
      Description: safeStr(row[1]),
      "SKU#": sku,
      Ordered: parseNumber(row[3]) ?? safeStr(row[3]),
      Haz_Info: safeStr(row[8]),
      "Bottle Label Location": safeStr(row[12]),
      "Box Label Location": safeStr(row[13])
    });
  }
  
  return rows;
}

// Use day sheet data directly (no source lookup)
function buildCleanRows(dayRows) {
  return dayRows.map(dr => {
    // Handle empty Bottle Label Location - show "IN-HOUSE"
    const bottleLocation = safeStr(dr["Bottle Label Location"]);
    const finalBottle = bottleLocation ? bottleLocation : "IN-HOUSE";
    
    // Handle empty Box Label Location - show "IN-HOUSE"
    const boxLocation = safeStr(dr["Box Label Location"]);
    const finalBox = boxLocation ? boxLocation : "IN-HOUSE";
    
    // Handle Haz_Info - if 0, show nothing
    let hazInfo = dr.Haz_Info;
    if (hazInfo === 0 || hazInfo === "0" || safeStr(hazInfo) === "0") {
      hazInfo = "";
    }
    
    return {
      Line: dr.Line,
      Description: dr.Description,
      "SKU#": dr["SKU#"],
      Ordered: dr.Ordered,
      Haz_Info: hazInfo,
      "Bottle Label Location": finalBottle,
      "Box Label Location": finalBox
    };
  });
}

function sheetToAoa(name) {
  const ws = workbook.Sheets[name];
  return XLSX.utils.sheet_to_json(ws, { header: 1, raw: true, defval: "" });
}

// Populate day sheet select and auto-select
function populateSheetSelects() {
  daySelect.innerHTML = "";

  for (const n of sheetNames) {
    const opt = document.createElement("option");
    opt.value = n; opt.textContent = n;
    daySelect.appendChild(opt);
  }

  // Auto-detect today's sheet or next available workday
  const todaySheet = findTodaySheet(sheetNames);
  if (todaySheet) {
    daySelect.value = todaySheet;
    const today = new Date();
    const todayFormat = getTodaySheetFormat();
    const match = todaySheet.match(/(\d{1,2})-(\d{1,2})/);
    if (match) {
      const sheetDate = `${match[1]}-${match[2]}`;
      if (sheetDate !== todayFormat) {
        console.log(`Today's sheet (${todayFormat}) not found. Showing next available workday: ${todaySheet}`);
      }
    }
  } else {
    // If no workday found in next 2 weeks, select first sheet
    daySelect.value = sheetNames[0] || sheetNames[1] || "";
    console.log(`No workday sheets found. Showing first available sheet.`);
  }
}

// Build clean table
function build() {
  if (!workbook) return;

  const dayName = daySelect.value;
  const dayAoa = sheetToAoa(dayName);

  const dayRows = extractDayRows(dayAoa);
  cleanRows = buildCleanRows(dayRows);

  // Update header with schedule info
  const shift = detectShift(dayName, dayAoa);
  const formattedDate = formatScheduleDate(dayName);
  
  scheduleDate.textContent = formattedDate;
  shiftBadge.textContent = shift;
  shiftBadge.dataset.shift = shift;
  
  // Update print header
  $("printDate").textContent = formattedDate;
  $("printShift").textContent = shift;
  $("printShift").dataset.shift = shift;

  renderCleanRows(cleanRows, dayName);
  btnPrint.disabled = cleanRows.length === 0;
  btnClearPicked.disabled = cleanRows.length === 0;
}

// Load XLSX file automatically
async function loadWorkbook() {
  try {
    const response = await fetch(XLSX_FILE_PATH);
    if (!response.ok) throw new Error(`Failed to load file: ${response.statusText}`);
    
    const buf = await response.arrayBuffer();
    workbook = XLSX.read(buf, { type: "array" });
    // Only include schedule day sheets (e.g. "01-05" and "01-05 PM")
    allSheetNames = workbook.SheetNames || [];
    sheetNames = allSheetNames.filter((n) => /^\s*\d{1,2}-\d{1,2}/.test(String(n)));

    populateSheetSelects();
    daySelect.disabled = false;
    
    // Load Source sheet for search
    loadSourceSheet();

    // Auto-build on load
    build();
  } catch (err) {
    console.error(err);
    scheduleDate.textContent = "Error loading file";
    shiftBadge.textContent = "â€”";
    alert(`Error loading file: ${err.message}. Make sure "${XLSX_FILE_PATH}" exists in the same directory.`);
  }
}

function setSourceStatus(msg) {
  if (!sourceSearchStatus) return;
  sourceSearchStatus.textContent = msg || "";
}

function renderSourceResults(records) {
  const tbody = sourceResultsTable.querySelector("tbody");
  tbody.innerHTML = "";

  if (!records.length) {
    tbody.innerHTML = '<tr><td colspan="8" style="text-align:center;padding:28px;color:var(--muted)">No results.</td></tr>';
    return;
  }

  const maxRows = 200;
  const shown = records.slice(0, maxRows);

  for (const r of shown) {
    const tr = document.createElement("tr");
    const cells = [
      r.itemNumber,
      r.description,
      r.hazInfo,
      r.insertInfo,
      r.labelLocation,
      r.boxLabelLocation,
      r.closureType,
      r.packType
    ];
    for (const v of cells) {
      const td = document.createElement("td");
      td.textContent = v == null ? "" : String(v);
      tr.appendChild(td);
    }
    tbody.appendChild(tr);
  }

  if (records.length > maxRows) {
    const tr = document.createElement("tr");
    const td = document.createElement("td");
    td.colSpan = 8;
    td.style.textAlign = "center";
    td.style.padding = "14px";
    td.style.color = "var(--muted)";
    td.textContent = `Showing first ${maxRows} of ${records.length} matches. Refine your search to narrow results.`;
    tr.appendChild(td);
    tbody.appendChild(tr);
  }
}

function normalizeHaz(value) {
  const s = safeStr(value);
  if (s === "0") return "";
  return s;
}

function loadSourceSheet() {
  sourceReady = false;
  sourceRecords = [];
  renderSourceResults([]);

  if (!workbook) {
    setSourceStatus("Source: workbook not loaded.");
    return;
  }

  const sourceName =
    allSheetNames.find(n => norm(n) === "source") ||
    pickSheetByNameLike(allSheetNames, "source");

  if (!sourceName || !workbook.Sheets[sourceName]) {
    setSourceStatus('Source sheet not found (expected a tab named "Source").');
    sourceSearch.disabled = true;
    sourceSearchBtn.disabled = true;
    sourceClearBtn.disabled = true;
    return;
  }

  const ws = workbook.Sheets[sourceName];
  // Use AOA so we can detect header row even if it's not row 1 (Source has a title block).
  const aoa = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "", raw: true });
  if (!aoa.length) {
    setSourceStatus('Source sheet is empty.');
    sourceSearch.disabled = false;
    sourceSearchBtn.disabled = false;
    sourceClearBtn.disabled = false;
    return;
  }

  const normCell = (v) => String(v ?? "").trim().toLowerCase();
  const isMatch = (cell, patterns) => patterns.some((p) => p.test(cell));

  // Detect the header row by scanning the top section for a row containing Item#/Description/etc.
  const headerPatterns = {
    item: [/^item\s*#?$/i, /\bitem\b/i, /\bsku\b/i, /\bitem\s*no\b/i, /\bitem\s*number\b/i],
    desc: [/\bdescription\b/i, /\bproduct\s*name\b/i],
    haz:  [/\bhaz\b/i, /\bhaz\s*class\b/i, /haz[_\s-]*info/i],
    insert: [/\binsert\b/i],
    bottle: [/\bbottle\s*label\b/i, /\blabel\s*id\b/i, /\blabel\b/i],
    box: [/\bbox\s*label\b/i, /\bcase\s*label\b/i],
    closure: [/\bclosure\b/i],
    pack: [/\bpack\b/i]
  };

  let headerRowIdx = -1;
  let headerScoreBest = -1;

  for (let r = 0; r < Math.min(60, aoa.length); r++) {
    const row = aoa[r] || [];
    let nonEmpty = 0;
    let hits = { item: 0, desc: 0, haz: 0, insert: 0, bottle: 0, box: 0, closure: 0, pack: 0 };

    for (let c = 0; c < row.length; c++) {
      const cell = normCell(row[c]);
      if (!cell) continue;
      nonEmpty++;
      for (const k of Object.keys(hits)) {
        if (isMatch(cell, headerPatterns[k])) hits[k]++;
      }
    }

    // Require at least item+description-like signals.
    const hasItem = hits.item > 0;
    const hasDesc = hits.desc > 0;
    if (!hasItem || !hasDesc) continue;

    // Prefer rows with more header hits + many filled cells.
    const score =
      (hits.item + hits.desc) * 50 +
      (hits.haz + hits.insert + hits.bottle + hits.box + hits.closure + hits.pack) * 10 +
      nonEmpty;

    if (score > headerScoreBest) {
      headerScoreBest = score;
      headerRowIdx = r;
    }
  }

  if (headerRowIdx < 0) {
    setSourceStatus('Source sheet loaded, but could not find a header row (expected columns like "Item#", "Description").');
    sourceSearch.disabled = false;
    sourceSearchBtn.disabled = false;
    sourceClearBtn.disabled = false;
    return;
  }

  const headerRow = aoa[headerRowIdx] || [];
  const findCol = (patterns) => {
    for (let c = 0; c < headerRow.length; c++) {
      const cell = normCell(headerRow[c]);
      if (!cell) continue;
      if (isMatch(cell, patterns)) return c;
    }
    return -1;
  };

  const itemCol = findCol(headerPatterns.item);
  const descCol = findCol(headerPatterns.desc);
  const hazCol = findCol(headerPatterns.haz);
  const insertCol = findCol(headerPatterns.insert);
  const bottleCol = findCol([/\bbottle\s*label\b/i, /\bbottle\s*label\s*location\b/i, /\bbottle\s*label\s*loc\b/i, /\blabel\s*location\b/i, /\bbottle\s*label\b/i]);
  const boxCol = findCol([/\bbox\s*label\b/i, /\bbox\s*label\s*location\b/i, /\bcase\s*label\b/i]);
  const closureCol = findCol([/\bclosure\s*type\b/i, /\bclosure\b/i]);
  const packCol = findCol([/\bpack\s*type\b/i, /\bpack\b/i]);

  if (itemCol < 0 || descCol < 0) {
    setSourceStatus('Source sheet header found, but missing Item#/Description columns.');
    sourceSearch.disabled = false;
    sourceSearchBtn.disabled = false;
    sourceClearBtn.disabled = false;
    return;
  }

  const recs = [];
  for (let r = headerRowIdx + 1; r < aoa.length; r++) {
    const row = aoa[r] || [];
    const itemNumber = safeStr(row[itemCol]);
    const description = safeStr(row[descCol]);
    if (!itemNumber && !description) continue;

    const hazInfo = normalizeHaz(hazCol >= 0 ? row[hazCol] : "");
    const insertInfo = safeStr(insertCol >= 0 ? row[insertCol] : "");
    const labelLocation = safeStr(bottleCol >= 0 ? row[bottleCol] : "");
    const boxLabelLocation = safeStr(boxCol >= 0 ? row[boxCol] : "");
    const closureType = safeStr(closureCol >= 0 ? row[closureCol] : "");
    const packType = safeStr(packCol >= 0 ? row[packCol] : "");

    recs.push({
      itemNumber,
      description,
      hazInfo,
      insertInfo,
      labelLocation,
      boxLabelLocation,
      closureType,
      packType,
      _searchText: `${itemNumber} ${description}`.toLowerCase()
    });
  }

  sourceRecords = recs;

  sourceReady = true;
  sourceSearch.disabled = false;
  sourceSearchBtn.disabled = false;
  sourceClearBtn.disabled = false;

  setSourceStatus(`Source loaded (${sourceRecords.length} rows).`);
}

function runSourceSearch() {
  if (!sourceReady) return;
  const q = safeStr(sourceSearch.value);
  if (!q) {
    setSourceStatus(`Source loaded (${sourceRecords.length} rows).`);
    renderSourceResults([]);
    return;
  }

  const needle = q.toLowerCase();
  const hits = sourceRecords.filter(r => r._searchText.includes(needle));
  setSourceStatus(`Found ${hits.length} result(s) for â€œ${q}â€.`);
  renderSourceResults(hits);
}

// Event listeners
daySelect.addEventListener("change", () => {
  if (!workbook) return;
  build(); // Auto-build when day sheet changes
});

btnPrint.addEventListener("click", () => { if (cleanRows.length) window.print(); });

const btnClearPicked = $("btnClearPicked");
btnClearPicked.addEventListener("click", () => {
  if (!workbook || !daySelect.value) return;
  
  const dayName = daySelect.value;
  const formattedDate = formatScheduleDate(dayName);
  if (!confirm(`Clear all picked labels for ${formattedDate}?\n\nThis will only clear picks for this day. Other days' picks will remain saved.\n\nThis cannot be undone.`)) return;
  
  // Clear all picked status for this day using the same row structure
  // We need to use the actual cleanRows that are currently displayed
  if (cleanRows && cleanRows.length > 0) {
    for (const row of cleanRows) {
      setPicked(dayName, row, "bottle", false);
      setPicked(dayName, row, "box", false);
      setPicked(dayName, row, "haz", false);
    }
  } else {
    // Fallback: rebuild rows if cleanRows not available
    const dayAoa = sheetToAoa(dayName);
    const dayRows = extractDayRows(dayAoa);
    const rows = buildCleanRows(dayRows);
    for (const row of rows) {
      setPicked(dayName, row, "bottle", false);
      setPicked(dayName, row, "box", false);
      setPicked(dayName, row, "haz", false);
    }
  }
  
  // Rebuild to refresh display
  build();
});

sourceSearchBtn.addEventListener("click", runSourceSearch);
sourceSearch.addEventListener("keyup", (e) => { if (e.key === "Enter") runSourceSearch(); });
sourceClearBtn.addEventListener("click", () => {
  sourceSearch.value = "";
  if (!sourceReady) return;
  setSourceStatus(`Source loaded (${sourceRecords.length} rows).`);
  renderSourceResults([]);
  sourceSearch.focus();
});

// Initialize
loadWorkbook();
</script>
</body>
</html>
